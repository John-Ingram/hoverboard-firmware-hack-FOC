ARM GAS  /tmp/ccNyZSr4.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"util.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.BLDC_Init,"ax",%progbits
  16              		.align	1
  17              		.global	BLDC_Init
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	BLDC_Init:
  25              	.LFB66:
  26              		.file 1 "Src/util.c"
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <stdlib.h> // for abs()
  23:Src/util.c    **** #include <string.h>
  24:Src/util.c    **** #include "stm32f1xx_hal.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "setup.h"
  27:Src/util.c    **** #include "config.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
  32:Src/util.c    **** 
ARM GAS  /tmp/ccNyZSr4.s 			page 2


  33:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  34:Src/util.c    **** #include "hd44780.h"
  35:Src/util.c    **** #endif
  36:Src/util.c    **** 
  37:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  38:Src/util.c    **** 
  39:Src/util.c    **** //------------------------------------------------------------------------
  40:Src/util.c    **** // Global variables set externally
  41:Src/util.c    **** //------------------------------------------------------------------------
  42:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  43:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  44:Src/util.c    **** extern UART_HandleTypeDef huart2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart3;
  46:Src/util.c    **** 
  47:Src/util.c    **** extern int16_t batVoltage;
  48:Src/util.c    **** extern uint8_t backwardDrive;
  49:Src/util.c    **** extern uint8_t buzzerCount;             // global variable for the buzzer counts. can be 1, 2, 3, 4
  50:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  51:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  52:Src/util.c    **** 
  53:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  54:Src/util.c    **** 
  55:Src/util.c    **** extern uint8_t nunchuk_data[6];
  56:Src/util.c    **** extern volatile uint32_t timeoutCntGen; // global counter for general timeout counter
  57:Src/util.c    **** extern volatile uint8_t  timeoutFlgGen; // global flag for general timeout counter
  58:Src/util.c    **** extern volatile uint32_t main_loop_counter;
  59:Src/util.c    **** 
  60:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  61:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  62:Src/util.c    **** #endif
  63:Src/util.c    **** 
  64:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  65:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  66:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  67:Src/util.c    **** #endif
  68:Src/util.c    **** 
  69:Src/util.c    **** 
  70:Src/util.c    **** //------------------------------------------------------------------------
  71:Src/util.c    **** // Global variables set here in util.c
  72:Src/util.c    **** //------------------------------------------------------------------------
  73:Src/util.c    **** // Matlab defines - from auto-code generation
  74:Src/util.c    **** //---------------
  75:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  76:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  77:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  78:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  79:Src/util.c    **** 
  80:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  81:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  82:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  83:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  84:Src/util.c    **** 
  85:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  86:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  87:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
  88:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
  89:Src/util.c    **** //---------------
ARM GAS  /tmp/ccNyZSr4.s 			page 3


  90:Src/util.c    **** 
  91:Src/util.c    **** uint8_t  inIdx = 0;
  92:Src/util.c    **** #if defined(PRI_INPUT1) && defined(PRI_INPUT2) && defined(AUX_INPUT1) && defined(AUX_INPUT2)
  93:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1}, {0, 0, 0, AUX_INPUT1} };
  94:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2}, {0, 0, 0, AUX_INPUT2} };
  95:Src/util.c    **** #else
  96:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1} };
  97:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2} };
  98:Src/util.c    **** #endif
  99:Src/util.c    **** 
 100:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
 101:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
 102:Src/util.c    **** uint8_t  timeoutFlgADC    = 0;          // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 103:Src/util.c    **** uint8_t  timeoutFlgSerial = 0;          // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 104:Src/util.c    **** 
 105:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 106:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 107:Src/util.c    **** 
 108:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 109:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 110:Src/util.c    **** #endif
 111:Src/util.c    **** 
 112:Src/util.c    **** #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 113:Src/util.c    **** uint8_t nunchuk_connected = 1;
 114:Src/util.c    **** #else
 115:Src/util.c    **** uint8_t nunchuk_connected = 0;
 116:Src/util.c    **** #endif
 117:Src/util.c    **** 
 118:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 119:Src/util.c    **** float    setDistance;
 120:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1337};       // Virtual address defined by the user: 0xFFFF va
 121:Src/util.c    **** static   uint16_t saveValue       = 0;
 122:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 123:Src/util.c    **** #elif !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 124:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
 125:Src/util.c    ****                                      1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018};
 126:Src/util.c    **** #else
 127:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000};       // Dummy virtual address to avoid warnings
 128:Src/util.c    **** #endif
 129:Src/util.c    **** 
 130:Src/util.c    **** 
 131:Src/util.c    **** //------------------------------------------------------------------------
 132:Src/util.c    **** // Local variables
 133:Src/util.c    **** //------------------------------------------------------------------------
 134:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 135:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 136:Src/util.c    **** 
 137:Src/util.c    **** 
 138:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 139:Src/util.c    ****   static uint8_t  cur_spd_valid  = 0;
 140:Src/util.c    ****   static uint8_t  inp_cal_valid  = 0;
 141:Src/util.c    **** #endif
 142:Src/util.c    **** 
 143:Src/util.c    **** #if defined(CONTROL_ADC)
 144:Src/util.c    **** static uint16_t timeoutCntADC = ADC_PROTECT_TIMEOUT;  // Timeout counter for ADC Protection
 145:Src/util.c    **** #endif
 146:Src/util.c    **** 
ARM GAS  /tmp/ccNyZSr4.s 			page 4


 147:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 148:Src/util.c    **** static uint8_t  rx_buffer_L[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 149:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
 150:Src/util.c    **** #endif
 151:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 152:Src/util.c    **** static uint16_t timeoutCntSerial_L = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 153:Src/util.c    **** static uint8_t  timeoutFlgSerial_L = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 154:Src/util.c    **** #endif
 155:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 156:Src/util.c    **** SerialSideboard Sideboard_L;
 157:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 158:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 159:Src/util.c    **** #endif
 160:Src/util.c    **** 
 161:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 162:Src/util.c    **** static uint8_t  rx_buffer_R[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 163:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 164:Src/util.c    **** #endif
 165:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 166:Src/util.c    **** static uint16_t timeoutCntSerial_R = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 167:Src/util.c    **** static uint8_t  timeoutFlgSerial_R = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 168:Src/util.c    **** #endif
 169:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 170:Src/util.c    **** SerialSideboard Sideboard_R;
 171:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 172:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 173:Src/util.c    **** #endif
 174:Src/util.c    **** 
 175:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2)
 176:Src/util.c    **** static SerialCommand commandL;
 177:Src/util.c    **** static SerialCommand commandL_raw;
 178:Src/util.c    **** static uint32_t commandL_len = sizeof(commandL);
 179:Src/util.c    ****   #ifdef CONTROL_IBUS
 180:Src/util.c    ****   static uint16_t ibusL_captured_value[IBUS_NUM_CHANNELS];
 181:Src/util.c    ****   #endif
 182:Src/util.c    **** #endif
 183:Src/util.c    **** 
 184:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3)
 185:Src/util.c    **** static SerialCommand commandR;
 186:Src/util.c    **** static SerialCommand commandR_raw;
 187:Src/util.c    **** static uint32_t commandR_len = sizeof(commandR);
 188:Src/util.c    ****   #ifdef CONTROL_IBUS
 189:Src/util.c    ****   static uint16_t ibusR_captured_value[IBUS_NUM_CHANNELS];
 190:Src/util.c    ****   #endif
 191:Src/util.c    **** #endif
 192:Src/util.c    **** 
 193:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 194:Src/util.c    **** static uint8_t button1;                 // Blue
 195:Src/util.c    **** static uint8_t button2;                 // Green
 196:Src/util.c    **** #endif
 197:Src/util.c    **** 
 198:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 199:Src/util.c    **** static uint8_t brakePressed;
 200:Src/util.c    **** #endif
 201:Src/util.c    **** 
 202:Src/util.c    **** #if defined(CRUISE_CONTROL_SUPPORT) || (defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTR
 203:Src/util.c    **** static uint8_t cruiseCtrlAcv = 0;
ARM GAS  /tmp/ccNyZSr4.s 			page 5


 204:Src/util.c    **** static uint8_t standstillAcv = 0;
 205:Src/util.c    **** #endif
 206:Src/util.c    **** 
 207:Src/util.c    **** /* =========================== Retargeting printf =========================== */
 208:Src/util.c    **** /* retarget the C library printf function to the USART */
 209:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 210:Src/util.c    ****   #ifdef __GNUC__
 211:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 212:Src/util.c    ****   #else
 213:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 214:Src/util.c    ****   #endif
 215:Src/util.c    ****   PUTCHAR_PROTOTYPE {
 216:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2)
 217:Src/util.c    ****       HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 1000);
 218:Src/util.c    ****     #elif defined(DEBUG_SERIAL_USART3)
 219:Src/util.c    ****       HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 1000);
 220:Src/util.c    ****     #endif
 221:Src/util.c    ****     return ch;
 222:Src/util.c    ****   }
 223:Src/util.c    ****   
 224:Src/util.c    ****   #ifdef __GNUC__
 225:Src/util.c    ****     int _write(int file, char *data, int len) {
 226:Src/util.c    ****       int i;
 227:Src/util.c    ****       for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 228:Src/util.c    ****       return len;
 229:Src/util.c    ****     }
 230:Src/util.c    ****   #endif
 231:Src/util.c    **** #endif
 232:Src/util.c    **** 
 233:Src/util.c    **** 
 234:Src/util.c    **** 
 235:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 236:Src/util.c    **** 
 237:Src/util.c    **** void BLDC_Init(void) {
  27              		.loc 1 237 22 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
 238:Src/util.c    ****   /* Set BLDC controller parameters */ 
 239:Src/util.c    ****   rtP_Left.b_angleMeasEna       = 0;            // Motor angle input: 0 = estimated angle, 1 = meas
  38              		.loc 1 239 3 view .LVU1
  39              		.loc 1 239 33 is_stmt 0 view .LVU2
  40 0002 224C     		ldr	r4, .L3
  41 0004 0023     		movs	r3, #0
  42 0006 84F8FB30 		strb	r3, [r4, #251]
 240:Src/util.c    ****   rtP_Left.z_selPhaCurMeasABC   = 0;            // Left motor measured current phases {Green, Blue}
  43              		.loc 1 240 3 is_stmt 1 view .LVU3
  44              		.loc 1 240 33 is_stmt 0 view .LVU4
  45 000a 84F8FA30 		strb	r3, [r4, #250]
 241:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
ARM GAS  /tmp/ccNyZSr4.s 			page 6


  46              		.loc 1 241 3 is_stmt 1 view .LVU5
  47              		.loc 1 241 33 is_stmt 0 view .LVU6
  48 000e 0223     		movs	r3, #2
  49 0010 84F8F930 		strb	r3, [r4, #249]
 242:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA;
  50              		.loc 1 242 3 is_stmt 1 view .LVU7
  51              		.loc 1 242 33 is_stmt 0 view .LVU8
  52 0014 0126     		movs	r6, #1
  53 0016 84F8FD60 		strb	r6, [r4, #253]
 243:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
  54              		.loc 1 243 3 is_stmt 1 view .LVU9
  55              		.loc 1 243 33 is_stmt 0 view .LVU10
  56 001a 45F6C053 		movw	r3, #24000
  57 001e A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 244:Src/util.c    ****   #if defined(SAFE_MODE_RPM)
 245:Src/util.c    ****   rtP_Left.n_max                = 2000 << 4;                       // fixdt(1,16,4)
  58              		.loc 1 245 3 is_stmt 1 view .LVU11
  59              		.loc 1 245 33 is_stmt 0 view .LVU12
  60 0022 4FF4FA43 		mov	r3, #32000
  61 0026 A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 246:Src/util.c    ****   #else
 247:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
 248:Src/util.c    ****   #endif
 249:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
  62              		.loc 1 249 3 is_stmt 1 view .LVU13
  63              		.loc 1 249 33 is_stmt 0 view .LVU14
  64 002a 84F8FE60 		strb	r6, [r4, #254]
 250:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
  65              		.loc 1 250 3 is_stmt 1 view .LVU15
  66              		.loc 1 250 33 is_stmt 0 view .LVU16
  67 002e 4FF49653 		mov	r3, #4800
  68 0032 A4F8D030 		strh	r3, [r4, #208]	@ movhi
 251:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
  69              		.loc 1 251 3 is_stmt 1 view .LVU17
  70              		.loc 1 251 33 is_stmt 0 view .LVU18
  71 0036 4FF4C873 		mov	r3, #400
  72 003a A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 252:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
  73              		.loc 1 252 3 is_stmt 1 view .LVU19
  74              		.loc 1 252 33 is_stmt 0 view .LVU20
  75 003e 4FF47A53 		mov	r3, #16000
  76 0042 A4F8E030 		strh	r3, [r4, #224]	@ movhi
 253:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
  77              		.loc 1 253 3 is_stmt 1 view .LVU21
  78              		.loc 1 253 33 is_stmt 0 view .LVU22
  79 0046 42F6E063 		movw	r3, #12000
  80 004a A4F8E230 		strh	r3, [r4, #226]	@ movhi
 254:Src/util.c    **** 
 255:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
  81              		.loc 1 255 3 is_stmt 1 view .LVU23
  82              		.loc 1 255 33 is_stmt 0 view .LVU24
  83 004e 104D     		ldr	r5, .L3+4
  84 0050 4FF48072 		mov	r2, #256
  85 0054 2146     		mov	r1, r4
  86 0056 2846     		mov	r0, r5
  87 0058 FFF7FEFF 		bl	memcpy
  88              	.LVL0:
ARM GAS  /tmp/ccNyZSr4.s 			page 7


 256:Src/util.c    ****   rtP_Right.z_selPhaCurMeasABC  = 1;            // Right motor measured current phases {Blue, Yello
  89              		.loc 1 256 3 is_stmt 1 view .LVU25
  90              		.loc 1 256 33 is_stmt 0 view .LVU26
  91 005c 85F8FA60 		strb	r6, [r5, #250]
 257:Src/util.c    **** 
 258:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 259:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
  92              		.loc 1 259 3 is_stmt 1 view .LVU27
  93              		.loc 1 259 33 is_stmt 0 view .LVU28
  94 0060 0C48     		ldr	r0, .L3+8
  95 0062 0460     		str	r4, [r0]
 260:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
  96              		.loc 1 260 3 is_stmt 1 view .LVU29
  97              		.loc 1 260 33 is_stmt 0 view .LVU30
  98 0064 0C4B     		ldr	r3, .L3+12
  99 0066 C360     		str	r3, [r0, #12]
 261:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
 100              		.loc 1 261 3 is_stmt 1 view .LVU31
 101              		.loc 1 261 33 is_stmt 0 view .LVU32
 102 0068 0C4B     		ldr	r3, .L3+16
 103 006a 4360     		str	r3, [r0, #4]
 262:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
 104              		.loc 1 262 3 is_stmt 1 view .LVU33
 105              		.loc 1 262 33 is_stmt 0 view .LVU34
 106 006c 0C4B     		ldr	r3, .L3+20
 107 006e 8360     		str	r3, [r0, #8]
 263:Src/util.c    **** 
 264:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 265:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
 108              		.loc 1 265 3 is_stmt 1 view .LVU35
 109              		.loc 1 265 33 is_stmt 0 view .LVU36
 110 0070 0C4C     		ldr	r4, .L3+24
 111 0072 2560     		str	r5, [r4]
 266:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
 112              		.loc 1 266 3 is_stmt 1 view .LVU37
 113              		.loc 1 266 33 is_stmt 0 view .LVU38
 114 0074 0C4B     		ldr	r3, .L3+28
 115 0076 E360     		str	r3, [r4, #12]
 267:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
 116              		.loc 1 267 3 is_stmt 1 view .LVU39
 117              		.loc 1 267 33 is_stmt 0 view .LVU40
 118 0078 0C4B     		ldr	r3, .L3+32
 119 007a 6360     		str	r3, [r4, #4]
 268:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
 120              		.loc 1 268 3 is_stmt 1 view .LVU41
 121              		.loc 1 268 33 is_stmt 0 view .LVU42
 122 007c 0C4B     		ldr	r3, .L3+36
 123 007e A360     		str	r3, [r4, #8]
 269:Src/util.c    **** 
 270:Src/util.c    ****   /* Initialize BLDC controllers */
 271:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
 124              		.loc 1 271 3 is_stmt 1 view .LVU43
 125 0080 FFF7FEFF 		bl	BLDC_controller_initialize
 126              	.LVL1:
 272:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
 127              		.loc 1 272 3 view .LVU44
 128 0084 2046     		mov	r0, r4
ARM GAS  /tmp/ccNyZSr4.s 			page 8


 129 0086 FFF7FEFF 		bl	BLDC_controller_initialize
 130              	.LVL2:
 273:Src/util.c    **** }
 131              		.loc 1 273 1 is_stmt 0 view .LVU45
 132 008a 70BD     		pop	{r4, r5, r6, pc}
 133              	.L4:
 134              		.align	2
 135              	.L3:
 136 008c 00000000 		.word	rtP_Left
 137 0090 00000000 		.word	rtP_Right
 138 0094 00000000 		.word	rtM_Left_
 139 0098 00000000 		.word	rtDW_Left
 140 009c 00000000 		.word	rtU_Left
 141 00a0 00000000 		.word	rtY_Left
 142 00a4 00000000 		.word	rtM_Right_
 143 00a8 00000000 		.word	rtDW_Right
 144 00ac 00000000 		.word	rtU_Right
 145 00b0 00000000 		.word	rtY_Right
 146              		.cfi_endproc
 147              	.LFE66:
 149              		.section	.text.Input_Lim_Init,"ax",%progbits
 150              		.align	1
 151              		.global	Input_Lim_Init
 152              		.syntax unified
 153              		.thumb
 154              		.thumb_func
 155              		.fpu softvfp
 157              	Input_Lim_Init:
 158              	.LFB67:
 274:Src/util.c    **** 
 275:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !
 159              		.loc 1 275 27 is_stmt 1 view -0
 160              		.cfi_startproc
 161              		@ args = 0, pretend = 0, frame = 0
 162              		@ frame_needed = 0, uses_anonymous_args = 0
 163              		@ link register save eliminated.
 276:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 164              		.loc 1 276 3 view .LVU47
 165              		.loc 1 276 15 is_stmt 0 view .LVU48
 166 0000 0C4B     		ldr	r3, .L9
 167 0002 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 168              		.loc 1 276 6 view .LVU49
 169 0006 1BB9     		cbnz	r3, .L6
 170              		.loc 1 276 43 discriminator 1 view .LVU50
 171 0008 0B4B     		ldr	r3, .L9+4
 172 000a 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 173              		.loc 1 276 31 discriminator 1 view .LVU51
 174 000e 43B1     		cbz	r3, .L7
 175              	.L6:
 277:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 176              		.loc 1 277 5 is_stmt 1 view .LVU52
 177              		.loc 1 277 15 is_stmt 0 view .LVU53
 178 0010 0A4B     		ldr	r3, .L9+8
 179 0012 4FF47A72 		mov	r2, #1000
 180 0016 1A80     		strh	r2, [r3]	@ movhi
 278:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 181              		.loc 1 278 5 is_stmt 1 view .LVU54
ARM GAS  /tmp/ccNyZSr4.s 			page 9


 182              		.loc 1 278 15 is_stmt 0 view .LVU55
 183 0018 094B     		ldr	r3, .L9+12
 184 001a 4FF61842 		movw	r2, #64536
 185 001e 1A80     		strh	r2, [r3]	@ movhi
 186 0020 7047     		bx	lr
 187              	.L7:
 279:Src/util.c    ****   } else {
 280:Src/util.c    ****     INPUT_MAX =  1000;
 188              		.loc 1 280 5 is_stmt 1 view .LVU56
 189              		.loc 1 280 15 is_stmt 0 view .LVU57
 190 0022 064B     		ldr	r3, .L9+8
 191 0024 4FF47A72 		mov	r2, #1000
 192 0028 1A80     		strh	r2, [r3]	@ movhi
 281:Src/util.c    ****     INPUT_MIN = -1000;
 193              		.loc 1 281 5 is_stmt 1 view .LVU58
 194              		.loc 1 281 15 is_stmt 0 view .LVU59
 195 002a 054B     		ldr	r3, .L9+12
 196 002c 4FF61842 		movw	r2, #64536
 197 0030 1A80     		strh	r2, [r3]	@ movhi
 282:Src/util.c    ****   }
 283:Src/util.c    **** }
 198              		.loc 1 283 1 view .LVU60
 199 0032 7047     		bx	lr
 200              	.L10:
 201              		.align	2
 202              	.L9:
 203 0034 00000000 		.word	rtP_Left
 204 0038 00000000 		.word	rtP_Right
 205 003c 00000000 		.word	.LANCHOR0
 206 0040 00000000 		.word	.LANCHOR1
 207              		.cfi_endproc
 208              	.LFE67:
 210              		.section	.text.poweronMelody,"ax",%progbits
 211              		.align	1
 212              		.global	poweronMelody
 213              		.syntax unified
 214              		.thumb
 215              		.thumb_func
 216              		.fpu softvfp
 218              	poweronMelody:
 219              	.LFB69:
 284:Src/util.c    **** 
 285:Src/util.c    **** void Input_Init(void) {
 286:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 287:Src/util.c    ****     PPM_Init();
 288:Src/util.c    ****   #endif
 289:Src/util.c    **** 
 290:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 291:Src/util.c    ****     PWM_Init();
 292:Src/util.c    ****   #endif
 293:Src/util.c    **** 
 294:Src/util.c    ****   #ifdef CONTROL_NUNCHUK
 295:Src/util.c    ****     I2C_Init();
 296:Src/util.c    ****     Nunchuk_Init();
 297:Src/util.c    ****   #endif
 298:Src/util.c    **** 
 299:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
ARM GAS  /tmp/ccNyZSr4.s 			page 10


 300:Src/util.c    ****     UART2_Init();
 301:Src/util.c    ****   #endif
 302:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 303:Src/util.c    ****     UART3_Init();
 304:Src/util.c    ****   #endif
 305:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 306:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 307:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 308:Src/util.c    ****   #endif
 309:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 310:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 311:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 312:Src/util.c    ****   #endif
 313:Src/util.c    **** 
 314:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 315:Src/util.c    ****     uint16_t writeCheck, readVal;
 316:Src/util.c    ****     HAL_FLASH_Unlock();
 317:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 318:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 319:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 320:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 321:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 322:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 330:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 331:Src/util.c    ****       }
 332:Src/util.c    ****     } else {
 333:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 334:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 335:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 336:Src/util.c    ****         } else {
 337:Src/util.c    ****           input1[i].typ = input1[i].typDef;
 338:Src/util.c    ****         }
 339:Src/util.c    ****         if (input2[i].typDef == 3) {
 340:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 341:Src/util.c    ****         } else {
 342:Src/util.c    ****           input2[i].typ = input2[i].typDef;
 343:Src/util.c    ****         }
 344:Src/util.c    ****       }
 345:Src/util.c    ****     }
 346:Src/util.c    ****     HAL_FLASH_Lock();
 347:Src/util.c    ****   #endif
 348:Src/util.c    **** 
 349:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 350:Src/util.c    ****     enable = 1;
 351:Src/util.c    **** 
 352:Src/util.c    ****     HAL_FLASH_Unlock();
 353:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 354:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 355:Src/util.c    ****     HAL_FLASH_Lock();
 356:Src/util.c    **** 
ARM GAS  /tmp/ccNyZSr4.s 			page 11


 357:Src/util.c    ****     setDistance = saveValue / 1000.0;
 358:Src/util.c    ****     if (setDistance < 0.2) {
 359:Src/util.c    ****       setDistance = 1.0;
 360:Src/util.c    ****     }
 361:Src/util.c    ****   #endif
 362:Src/util.c    **** 
 363:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 364:Src/util.c    ****     I2C_Init();
 365:Src/util.c    ****     HAL_Delay(50);
 366:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 367:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 368:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 369:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 370:Src/util.c    ****     lcd.type                    = TYPE0;
 371:Src/util.c    **** 
 372:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
 373:Src/util.c    ****         // error occured
 374:Src/util.c    ****         //TODO while(1);
 375:Src/util.c    ****     }
 376:Src/util.c    **** 
 377:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 378:Src/util.c    ****     HAL_Delay(5);
 379:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 380:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 381:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 382:Src/util.c    ****     #else
 383:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 384:Src/util.c    ****     #endif
 385:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 386:Src/util.c    ****   #endif
 387:Src/util.c    **** 
 388:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 389:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 390:Src/util.c    ****     HAL_Delay(5);
 391:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 392:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 393:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 394:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 395:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 396:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 397:Src/util.c    ****   #endif
 398:Src/util.c    **** }
 399:Src/util.c    **** 
 400:Src/util.c    **** /**
 401:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 402:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 403:Src/util.c    ****   * @param  huart: UART handle.
 404:Src/util.c    ****   * @retval None
 405:Src/util.c    ****   */
 406:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 407:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 408:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 409:Src/util.c    **** {  
 410:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);    /* Disable PE (Parity Error) interrupts */  
 411:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);     /* Disable EIE (Frame error, noise error, ove
 412:Src/util.c    **** }
 413:Src/util.c    **** #endif
ARM GAS  /tmp/ccNyZSr4.s 			page 12


 414:Src/util.c    **** 
 415:Src/util.c    **** 
 416:Src/util.c    **** /* =========================== General Functions =========================== */
 417:Src/util.c    **** 
 418:Src/util.c    **** void poweronMelody(void) {
 220              		.loc 1 418 26 is_stmt 1 view -0
 221              		.cfi_startproc
 222              		@ args = 0, pretend = 0, frame = 0
 223              		@ frame_needed = 0, uses_anonymous_args = 0
 224 0000 10B5     		push	{r4, lr}
 225              	.LCFI1:
 226              		.cfi_def_cfa_offset 8
 227              		.cfi_offset 4, -8
 228              		.cfi_offset 14, -4
 419:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 229              		.loc 1 419 5 view .LVU62
 230              		.loc 1 419 17 is_stmt 0 view .LVU63
 231 0002 084B     		ldr	r3, .L15
 232 0004 0022     		movs	r2, #0
 233 0006 1A70     		strb	r2, [r3]
 420:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 234              		.loc 1 420 5 is_stmt 1 view .LVU64
 235              	.LBB2:
 236              		.loc 1 420 10 view .LVU65
 237              	.LVL3:
 238              		.loc 1 420 14 is_stmt 0 view .LVU66
 239 0008 0824     		movs	r4, #8
 240              		.loc 1 420 5 view .LVU67
 241 000a 05E0     		b	.L12
 242              	.LVL4:
 243              	.L13:
 421:Src/util.c    ****       buzzerFreq = (uint8_t)i;
 244              		.loc 1 421 7 is_stmt 1 discriminator 3 view .LVU68
 245              		.loc 1 421 18 is_stmt 0 discriminator 3 view .LVU69
 246 000c 064B     		ldr	r3, .L15+4
 247 000e 1C70     		strb	r4, [r3]
 422:Src/util.c    ****       HAL_Delay(100);
 248              		.loc 1 422 7 is_stmt 1 discriminator 3 view .LVU70
 249 0010 6420     		movs	r0, #100
 250 0012 FFF7FEFF 		bl	HAL_Delay
 251              	.LVL5:
 420:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 252              		.loc 1 420 29 discriminator 3 view .LVU71
 420:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 253              		.loc 1 420 30 is_stmt 0 discriminator 3 view .LVU72
 254 0016 013C     		subs	r4, r4, #1
 255              	.LVL6:
 256              	.L12:
 420:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 257              		.loc 1 420 21 is_stmt 1 discriminator 1 view .LVU73
 420:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 258              		.loc 1 420 5 is_stmt 0 discriminator 1 view .LVU74
 259 0018 002C     		cmp	r4, #0
 260 001a F7DA     		bge	.L13
 261              	.LBE2:
 423:Src/util.c    ****     }
 424:Src/util.c    ****     buzzerFreq = 0;
ARM GAS  /tmp/ccNyZSr4.s 			page 13


 262              		.loc 1 424 5 is_stmt 1 view .LVU75
 263              		.loc 1 424 16 is_stmt 0 view .LVU76
 264 001c 024B     		ldr	r3, .L15+4
 265 001e 0022     		movs	r2, #0
 266 0020 1A70     		strb	r2, [r3]
 425:Src/util.c    **** }
 267              		.loc 1 425 1 view .LVU77
 268 0022 10BD     		pop	{r4, pc}
 269              	.LVL7:
 270              	.L16:
 271              		.loc 1 425 1 view .LVU78
 272              		.align	2
 273              	.L15:
 274 0024 00000000 		.word	buzzerCount
 275 0028 00000000 		.word	buzzerFreq
 276              		.cfi_endproc
 277              	.LFE69:
 279              		.section	.text.beepCount,"ax",%progbits
 280              		.align	1
 281              		.global	beepCount
 282              		.syntax unified
 283              		.thumb
 284              		.thumb_func
 285              		.fpu softvfp
 287              	beepCount:
 288              	.LVL8:
 289              	.LFB70:
 426:Src/util.c    **** 
 427:Src/util.c    **** void beepCount(uint8_t cnt, uint8_t freq, uint8_t pattern) {
 290              		.loc 1 427 60 is_stmt 1 view -0
 291              		.cfi_startproc
 292              		@ args = 0, pretend = 0, frame = 0
 293              		@ frame_needed = 0, uses_anonymous_args = 0
 294              		@ link register save eliminated.
 428:Src/util.c    ****     buzzerCount   = cnt;
 295              		.loc 1 428 5 view .LVU80
 296              		.loc 1 428 19 is_stmt 0 view .LVU81
 297 0000 034B     		ldr	r3, .L18
 298 0002 1870     		strb	r0, [r3]
 429:Src/util.c    ****     buzzerFreq    = freq;
 299              		.loc 1 429 5 is_stmt 1 view .LVU82
 300              		.loc 1 429 19 is_stmt 0 view .LVU83
 301 0004 034B     		ldr	r3, .L18+4
 302 0006 1970     		strb	r1, [r3]
 430:Src/util.c    ****     buzzerPattern = pattern;
 303              		.loc 1 430 5 is_stmt 1 view .LVU84
 304              		.loc 1 430 19 is_stmt 0 view .LVU85
 305 0008 034B     		ldr	r3, .L18+8
 306 000a 1A70     		strb	r2, [r3]
 431:Src/util.c    **** }
 307              		.loc 1 431 1 view .LVU86
 308 000c 7047     		bx	lr
 309              	.L19:
 310 000e 00BF     		.align	2
 311              	.L18:
 312 0010 00000000 		.word	buzzerCount
 313 0014 00000000 		.word	buzzerFreq
ARM GAS  /tmp/ccNyZSr4.s 			page 14


 314 0018 00000000 		.word	buzzerPattern
 315              		.cfi_endproc
 316              	.LFE70:
 318              		.section	.text.beepLong,"ax",%progbits
 319              		.align	1
 320              		.global	beepLong
 321              		.syntax unified
 322              		.thumb
 323              		.thumb_func
 324              		.fpu softvfp
 326              	beepLong:
 327              	.LVL9:
 328              	.LFB71:
 432:Src/util.c    **** 
 433:Src/util.c    **** void beepLong(uint8_t freq) {
 329              		.loc 1 433 29 is_stmt 1 view -0
 330              		.cfi_startproc
 331              		@ args = 0, pretend = 0, frame = 0
 332              		@ frame_needed = 0, uses_anonymous_args = 0
 333              		.loc 1 433 29 is_stmt 0 view .LVU88
 334 0000 38B5     		push	{r3, r4, r5, lr}
 335              	.LCFI2:
 336              		.cfi_def_cfa_offset 16
 337              		.cfi_offset 3, -16
 338              		.cfi_offset 4, -12
 339              		.cfi_offset 5, -8
 340              		.cfi_offset 14, -4
 434:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 341              		.loc 1 434 5 is_stmt 1 view .LVU89
 342              		.loc 1 434 17 is_stmt 0 view .LVU90
 343 0002 0025     		movs	r5, #0
 344 0004 044B     		ldr	r3, .L22
 345 0006 1D70     		strb	r5, [r3]
 435:Src/util.c    ****     buzzerFreq = freq;
 346              		.loc 1 435 5 is_stmt 1 view .LVU91
 347              		.loc 1 435 16 is_stmt 0 view .LVU92
 348 0008 044C     		ldr	r4, .L22+4
 349 000a 2070     		strb	r0, [r4]
 436:Src/util.c    ****     HAL_Delay(500);
 350              		.loc 1 436 5 is_stmt 1 view .LVU93
 351 000c 4FF4FA70 		mov	r0, #500
 352              	.LVL10:
 353              		.loc 1 436 5 is_stmt 0 view .LVU94
 354 0010 FFF7FEFF 		bl	HAL_Delay
 355              	.LVL11:
 437:Src/util.c    ****     buzzerFreq = 0;
 356              		.loc 1 437 5 is_stmt 1 view .LVU95
 357              		.loc 1 437 16 is_stmt 0 view .LVU96
 358 0014 2570     		strb	r5, [r4]
 438:Src/util.c    **** }
 359              		.loc 1 438 1 view .LVU97
 360 0016 38BD     		pop	{r3, r4, r5, pc}
 361              	.L23:
 362              		.align	2
 363              	.L22:
 364 0018 00000000 		.word	buzzerCount
 365 001c 00000000 		.word	buzzerFreq
ARM GAS  /tmp/ccNyZSr4.s 			page 15


 366              		.cfi_endproc
 367              	.LFE71:
 369              		.section	.text.beepShort,"ax",%progbits
 370              		.align	1
 371              		.global	beepShort
 372              		.syntax unified
 373              		.thumb
 374              		.thumb_func
 375              		.fpu softvfp
 377              	beepShort:
 378              	.LVL12:
 379              	.LFB72:
 439:Src/util.c    **** 
 440:Src/util.c    **** void beepShort(uint8_t freq) {
 380              		.loc 1 440 30 is_stmt 1 view -0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              		.loc 1 440 30 is_stmt 0 view .LVU99
 385 0000 38B5     		push	{r3, r4, r5, lr}
 386              	.LCFI3:
 387              		.cfi_def_cfa_offset 16
 388              		.cfi_offset 3, -16
 389              		.cfi_offset 4, -12
 390              		.cfi_offset 5, -8
 391              		.cfi_offset 14, -4
 441:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 392              		.loc 1 441 5 is_stmt 1 view .LVU100
 393              		.loc 1 441 17 is_stmt 0 view .LVU101
 394 0002 0025     		movs	r5, #0
 395 0004 044B     		ldr	r3, .L26
 396 0006 1D70     		strb	r5, [r3]
 442:Src/util.c    ****     buzzerFreq = freq;
 397              		.loc 1 442 5 is_stmt 1 view .LVU102
 398              		.loc 1 442 16 is_stmt 0 view .LVU103
 399 0008 044C     		ldr	r4, .L26+4
 400 000a 2070     		strb	r0, [r4]
 443:Src/util.c    ****     HAL_Delay(100);
 401              		.loc 1 443 5 is_stmt 1 view .LVU104
 402 000c 6420     		movs	r0, #100
 403              	.LVL13:
 404              		.loc 1 443 5 is_stmt 0 view .LVU105
 405 000e FFF7FEFF 		bl	HAL_Delay
 406              	.LVL14:
 444:Src/util.c    ****     buzzerFreq = 0;
 407              		.loc 1 444 5 is_stmt 1 view .LVU106
 408              		.loc 1 444 16 is_stmt 0 view .LVU107
 409 0012 2570     		strb	r5, [r4]
 445:Src/util.c    **** }
 410              		.loc 1 445 1 view .LVU108
 411 0014 38BD     		pop	{r3, r4, r5, pc}
 412              	.L27:
 413 0016 00BF     		.align	2
 414              	.L26:
 415 0018 00000000 		.word	buzzerCount
 416 001c 00000000 		.word	buzzerFreq
 417              		.cfi_endproc
ARM GAS  /tmp/ccNyZSr4.s 			page 16


 418              	.LFE72:
 420              		.section	.text.beepShortMany,"ax",%progbits
 421              		.align	1
 422              		.global	beepShortMany
 423              		.syntax unified
 424              		.thumb
 425              		.thumb_func
 426              		.fpu softvfp
 428              	beepShortMany:
 429              	.LVL15:
 430              	.LFB73:
 446:Src/util.c    **** 
 447:Src/util.c    **** void beepShortMany(uint8_t cnt, int8_t dir) {
 431              		.loc 1 447 45 is_stmt 1 view -0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 435              		.loc 1 447 45 is_stmt 0 view .LVU110
 436 0000 38B5     		push	{r3, r4, r5, lr}
 437              	.LCFI4:
 438              		.cfi_def_cfa_offset 16
 439              		.cfi_offset 3, -16
 440              		.cfi_offset 4, -12
 441              		.cfi_offset 5, -8
 442              		.cfi_offset 14, -4
 443 0002 0446     		mov	r4, r0
 448:Src/util.c    ****     if (dir >= 0) {   // increasing tone
 444              		.loc 1 448 5 is_stmt 1 view .LVU111
 445              		.loc 1 448 8 is_stmt 0 view .LVU112
 446 0004 0029     		cmp	r1, #0
 447 0006 15DB     		blt	.L34
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 448              		.loc 1 449 7 is_stmt 1 view .LVU113
 449              	.LBB3:
 450              		.loc 1 449 11 view .LVU114
 451              		.loc 1 449 19 is_stmt 0 view .LVU115
 452 0008 4400     		lsls	r4, r0, #1
 453 000a E4B2     		uxtb	r4, r4
 454              	.LVL16:
 455              		.loc 1 449 7 view .LVU116
 456 000c 05E0     		b	.L30
 457              	.LVL17:
 458              	.L31:
 450:Src/util.c    ****         beepShort(i + 3);
 459              		.loc 1 450 9 is_stmt 1 discriminator 3 view .LVU117
 460 000e E01C     		adds	r0, r4, #3
 461 0010 C0B2     		uxtb	r0, r0
 462 0012 FFF7FEFF 		bl	beepShort
 463              	.LVL18:
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 464              		.loc 1 449 38 discriminator 3 view .LVU118
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 465              		.loc 1 449 39 is_stmt 0 discriminator 3 view .LVU119
 466 0016 023C     		subs	r4, r4, #2
 467              	.LVL19:
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 468              		.loc 1 449 39 discriminator 3 view .LVU120
ARM GAS  /tmp/ccNyZSr4.s 			page 17


 469 0018 E4B2     		uxtb	r4, r4
 470              	.LVL20:
 471              	.L30:
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 472              		.loc 1 449 30 is_stmt 1 discriminator 1 view .LVU121
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 473              		.loc 1 449 7 is_stmt 0 discriminator 1 view .LVU122
 474 001a 012C     		cmp	r4, #1
 475 001c F7D8     		bhi	.L31
 476              	.LVL21:
 477              	.L28:
 449:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 478              		.loc 1 449 7 discriminator 1 view .LVU123
 479              	.LBE3:
 451:Src/util.c    ****       }
 452:Src/util.c    ****     } else {          // decreasing tone
 453:Src/util.c    ****       for(uint8_t i = 2; i <= 2*cnt; i=i+2) {
 454:Src/util.c    ****         beepShort(i + 3);
 455:Src/util.c    ****       }
 456:Src/util.c    ****     }
 457:Src/util.c    **** }
 480              		.loc 1 457 1 view .LVU124
 481 001e 38BD     		pop	{r3, r4, r5, pc}
 482              	.LVL22:
 483              	.L33:
 484              	.LBB4:
 454:Src/util.c    ****       }
 485              		.loc 1 454 9 is_stmt 1 discriminator 3 view .LVU125
 486 0020 E81C     		adds	r0, r5, #3
 487 0022 C0B2     		uxtb	r0, r0
 488 0024 FFF7FEFF 		bl	beepShort
 489              	.LVL23:
 453:Src/util.c    ****         beepShort(i + 3);
 490              		.loc 1 453 38 discriminator 3 view .LVU126
 453:Src/util.c    ****         beepShort(i + 3);
 491              		.loc 1 453 39 is_stmt 0 discriminator 3 view .LVU127
 492 0028 0235     		adds	r5, r5, #2
 493              	.LVL24:
 453:Src/util.c    ****         beepShort(i + 3);
 494              		.loc 1 453 39 discriminator 3 view .LVU128
 495 002a EDB2     		uxtb	r5, r5
 496              	.LVL25:
 497              	.L29:
 453:Src/util.c    ****         beepShort(i + 3);
 498              		.loc 1 453 26 is_stmt 1 discriminator 1 view .LVU129
 453:Src/util.c    ****         beepShort(i + 3);
 499              		.loc 1 453 7 is_stmt 0 discriminator 1 view .LVU130
 500 002c B5EB440F 		cmp	r5, r4, lsl #1
 501 0030 F6DD     		ble	.L33
 502 0032 F4E7     		b	.L28
 503              	.LVL26:
 504              	.L34:
 453:Src/util.c    ****         beepShort(i + 3);
 505              		.loc 1 453 19 view .LVU131
 506 0034 0225     		movs	r5, #2
 507 0036 F9E7     		b	.L29
 508              	.LBE4:
ARM GAS  /tmp/ccNyZSr4.s 			page 18


 509              		.cfi_endproc
 510              	.LFE73:
 512              		.section	.text.calcAvgSpeed,"ax",%progbits
 513              		.align	1
 514              		.global	calcAvgSpeed
 515              		.syntax unified
 516              		.thumb
 517              		.thumb_func
 518              		.fpu softvfp
 520              	calcAvgSpeed:
 521              	.LFB74:
 458:Src/util.c    **** 
 459:Src/util.c    **** void calcAvgSpeed(void) {
 522              		.loc 1 459 25 is_stmt 1 view -0
 523              		.cfi_startproc
 524              		@ args = 0, pretend = 0, frame = 0
 525              		@ frame_needed = 0, uses_anonymous_args = 0
 526              		@ link register save eliminated.
 460:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 461:Src/util.c    ****     #if   !defined(INVERT_L_DIRECTION) && !defined(INVERT_R_DIRECTION)
 462:Src/util.c    ****       speedAvg    = ( rtY_Left.n_mot - rtY_Right.n_mot) / 2;
 463:Src/util.c    ****     #elif !defined(INVERT_L_DIRECTION) &&  defined(INVERT_R_DIRECTION)
 464:Src/util.c    ****       speedAvg    = ( rtY_Left.n_mot + rtY_Right.n_mot) / 2;
 465:Src/util.c    ****     #elif  defined(INVERT_L_DIRECTION) && !defined(INVERT_R_DIRECTION)
 466:Src/util.c    ****       speedAvg    = (-rtY_Left.n_mot - rtY_Right.n_mot) / 2;
 467:Src/util.c    ****     #elif  defined(INVERT_L_DIRECTION) &&  defined(INVERT_R_DIRECTION)
 468:Src/util.c    ****       speedAvg    = (-rtY_Left.n_mot + rtY_Right.n_mot) / 2;
 527              		.loc 1 468 7 view .LVU133
 528              		.loc 1 468 49 is_stmt 0 view .LVU134
 529 0000 094B     		ldr	r3, .L37
 530 0002 B3F90830 		ldrsh	r3, [r3, #8]
 531              		.loc 1 468 31 view .LVU135
 532 0006 094A     		ldr	r2, .L37+4
 533 0008 B2F90820 		ldrsh	r2, [r2, #8]
 534              		.loc 1 468 38 view .LVU136
 535 000c 9B1A     		subs	r3, r3, r2
 536              		.loc 1 468 57 view .LVU137
 537 000e 03EBD373 		add	r3, r3, r3, lsr #31
 538              		.loc 1 468 19 view .LVU138
 539 0012 43F34F03 		sbfx	r3, r3, #1, #16
 540 0016 064A     		ldr	r2, .L37+8
 541 0018 1380     		strh	r3, [r2]	@ movhi
 469:Src/util.c    ****     #endif
 470:Src/util.c    **** 
 471:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
 472:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 542              		.loc 1 472 5 is_stmt 1 view .LVU139
 473:Src/util.c    ****       speedAvg    = -speedAvg;
 474:Src/util.c    ****     } 
 475:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 543              		.loc 1 475 5 view .LVU140
 544              		.loc 1 475 21 is_stmt 0 view .LVU141
 545 001a 002B     		cmp	r3, #0
 546 001c B8BF     		it	lt
 547 001e 5B42     		rsblt	r3, r3, #0
 548              		.loc 1 475 19 view .LVU142
 549 0020 044A     		ldr	r2, .L37+12
ARM GAS  /tmp/ccNyZSr4.s 			page 19


 550 0022 1380     		strh	r3, [r2]	@ movhi
 476:Src/util.c    **** }
 551              		.loc 1 476 1 view .LVU143
 552 0024 7047     		bx	lr
 553              	.L38:
 554 0026 00BF     		.align	2
 555              	.L37:
 556 0028 00000000 		.word	rtY_Right
 557 002c 00000000 		.word	rtY_Left
 558 0030 00000000 		.word	speedAvg
 559 0034 00000000 		.word	speedAvgAbs
 560              		.cfi_endproc
 561              	.LFE74:
 563              		.section	.text.safeModeOff,"ax",%progbits
 564              		.align	1
 565              		.global	safeModeOff
 566              		.syntax unified
 567              		.thumb
 568              		.thumb_func
 569              		.fpu softvfp
 571              	safeModeOff:
 572              	.LFB76:
 477:Src/util.c    **** 
 478:Src/util.c    ****  /*
 479:Src/util.c    ****  * Auto-calibration of the ADC Limits
 480:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 481:Src/util.c    ****  * Procedure:
 482:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 483:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
 484:Src/util.c    ****  * - release potentiometers to the resting postion
 485:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 486:Src/util.c    ****  * The Values will be saved to flash. Values are persistent if you flash with platformio. To erase 
 487:Src/util.c    ****  */
 488:Src/util.c    **** void adcCalibLim(void) {
 489:Src/util.c    ****   calcAvgSpeed();
 490:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 491:Src/util.c    ****     return;
 492:Src/util.c    ****   }
 493:Src/util.c    **** 
 494:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 495:Src/util.c    **** 
 496:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 497:Src/util.c    ****   printf("Input calibration started...\r\n");
 498:Src/util.c    ****   #endif
 499:Src/util.c    **** 
 500:Src/util.c    ****   readInputRaw();
 501:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 502:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 503:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 504:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 505:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 506:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 507:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 508:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 509:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 510:Src/util.c    ****   int16_t  input_margin    = 0;
 511:Src/util.c    ****   uint16_t input_cal_timeout = 0;
ARM GAS  /tmp/ccNyZSr4.s 			page 20


 512:Src/util.c    ****   
 513:Src/util.c    ****   #ifdef CONTROL_ADC
 514:Src/util.c    ****   if (inIdx == CONTROL_ADC) {
 515:Src/util.c    ****     input_margin = ADC_MARGIN;
 516:Src/util.c    ****   }
 517:Src/util.c    ****   #endif
 518:Src/util.c    **** 
 519:Src/util.c    ****   // Extract MIN, MAX and MID from ADC while the power button is not pressed
 520:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && input_cal_timeout++ < 4000) {   // 20 sec ti
 521:Src/util.c    ****     readInputRaw();
 522:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 523:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 524:Src/util.c    ****     
 525:Src/util.c    ****     INPUT1_MID_temp = (int16_t)(input1_fixdt >> 16);// CLAMP(input1_fixdt >> 16, INPUT1_MIN, INPUT1
 526:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 527:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 528:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 529:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 530:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 531:Src/util.c    ****     HAL_Delay(5);
 532:Src/util.c    ****   }
 533:Src/util.c    **** 
 534:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 535:Src/util.c    ****   printf("Input1 is ");
 536:Src/util.c    ****   #endif
 537:Src/util.c    ****   input1[inIdx].typ = checkInputType(INPUT1_MIN_temp, INPUT1_MID_temp, INPUT1_MAX_temp);
 538:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 539:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 540:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 541:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 542:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 543:Src/util.c    ****     printf("..OK\r\n");
 544:Src/util.c    ****     #endif
 545:Src/util.c    ****   } else {
 546:Src/util.c    ****     input1[inIdx].typ = 0; // Disable input
 547:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 548:Src/util.c    ****     printf("..NOK\r\n");
 549:Src/util.c    ****     #endif
 550:Src/util.c    ****   }
 551:Src/util.c    **** 
 552:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 553:Src/util.c    ****   printf("Input2 is ");
 554:Src/util.c    ****   #endif
 555:Src/util.c    ****   input2[inIdx].typ = checkInputType(INPUT2_MIN_temp, INPUT2_MID_temp, INPUT2_MAX_temp);
 556:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 557:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 558:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 559:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 560:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 561:Src/util.c    ****     printf("..OK\r\n");
 562:Src/util.c    ****     #endif
 563:Src/util.c    ****   } else {
 564:Src/util.c    ****     input2[inIdx].typ = 0; // Disable input
 565:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 566:Src/util.c    ****     printf("..NOK\r\n");
 567:Src/util.c    ****     #endif
 568:Src/util.c    ****   }
ARM GAS  /tmp/ccNyZSr4.s 			page 21


 569:Src/util.c    ****   inp_cal_valid = 1;    // Mark calibration to be saved in Flash at shutdown
 570:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 571:Src/util.c    ****   printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i MAX:%i\
 572:Src/util.c    ****           input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 573:Src/util.c    ****           input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 574:Src/util.c    ****   #endif
 575:Src/util.c    **** 
 576:Src/util.c    **** #endif
 577:Src/util.c    **** }
 578:Src/util.c    **** /*
 579:Src/util.c    **** * Turn off safe mode by setting the maximum speed back to defaults
 580:Src/util.c    **** * Procedure:
 581:Src/util.c    **** * - press the power button for more than 5 sec and immediatelly after the beep sound press one more
 582:Src/util.c    **** */
 583:Src/util.c    **** void safeModeOff(void)  {
 573              		.loc 1 583 25 is_stmt 1 view -0
 574              		.cfi_startproc
 575              		@ args = 0, pretend = 0, frame = 0
 576              		@ frame_needed = 0, uses_anonymous_args = 0
 577 0000 08B5     		push	{r3, lr}
 578              	.LCFI5:
 579              		.cfi_def_cfa_offset 8
 580              		.cfi_offset 3, -8
 581              		.cfi_offset 14, -4
 584:Src/util.c    ****   calcAvgSpeed();
 582              		.loc 1 584 3 view .LVU145
 583 0002 FFF7FEFF 		bl	calcAvgSpeed
 584              	.LVL27:
 585:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 585              		.loc 1 585 3 view .LVU146
 586              		.loc 1 585 19 is_stmt 0 view .LVU147
 587 0006 0D4B     		ldr	r3, .L43
 588 0008 B3F90030 		ldrsh	r3, [r3]
 589              		.loc 1 585 6 view .LVU148
 590 000c 052B     		cmp	r3, #5
 591 000e 00DD     		ble	.L42
 592              	.L39:
 586:Src/util.c    ****     return;
 587:Src/util.c    ****   }
 588:Src/util.c    ****   rtP_Left.n_max = rtP_Right.n_max  = (N_MOT_MAX << 4);  
 589:Src/util.c    ****   beepShort(5);
 590:Src/util.c    ****   beepShort(5);
 591:Src/util.c    ****   beepShort(5);
 592:Src/util.c    ****   beepShort(5);              
 593:Src/util.c    **** 
 594:Src/util.c    **** }
 593              		.loc 1 594 1 view .LVU149
 594 0010 08BD     		pop	{r3, pc}
 595              	.L42:
 588:Src/util.c    ****   beepShort(5);
 596              		.loc 1 588 3 is_stmt 1 view .LVU150
 588:Src/util.c    ****   beepShort(5);
 597              		.loc 1 588 37 is_stmt 0 view .LVU151
 598 0012 4FF47A53 		mov	r3, #16000
 599 0016 0A4A     		ldr	r2, .L43+4
 600 0018 A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 588:Src/util.c    ****   beepShort(5);
ARM GAS  /tmp/ccNyZSr4.s 			page 22


 601              		.loc 1 588 18 view .LVU152
 602 001c 094A     		ldr	r2, .L43+8
 603 001e A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 589:Src/util.c    ****   beepShort(5);
 604              		.loc 1 589 3 is_stmt 1 view .LVU153
 605 0022 0520     		movs	r0, #5
 606 0024 FFF7FEFF 		bl	beepShort
 607              	.LVL28:
 590:Src/util.c    ****   beepShort(5);
 608              		.loc 1 590 3 view .LVU154
 609 0028 0520     		movs	r0, #5
 610 002a FFF7FEFF 		bl	beepShort
 611              	.LVL29:
 591:Src/util.c    ****   beepShort(5);              
 612              		.loc 1 591 3 view .LVU155
 613 002e 0520     		movs	r0, #5
 614 0030 FFF7FEFF 		bl	beepShort
 615              	.LVL30:
 592:Src/util.c    **** 
 616              		.loc 1 592 3 view .LVU156
 617 0034 0520     		movs	r0, #5
 618 0036 FFF7FEFF 		bl	beepShort
 619              	.LVL31:
 620 003a E9E7     		b	.L39
 621              	.L44:
 622              		.align	2
 623              	.L43:
 624 003c 00000000 		.word	speedAvgAbs
 625 0040 00000000 		.word	rtP_Right
 626 0044 00000000 		.word	rtP_Left
 627              		.cfi_endproc
 628              	.LFE76:
 630              		.section	.text.standstillHold,"ax",%progbits
 631              		.align	1
 632              		.global	standstillHold
 633              		.syntax unified
 634              		.thumb
 635              		.thumb_func
 636              		.fpu softvfp
 638              	standstillHold:
 639              	.LFB78:
 595:Src/util.c    ****  /*
 596:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 597:Src/util.c    ****  * Procedure:
 598:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 599:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
 600:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 601:Src/util.c    ****  */
 602:Src/util.c    **** void updateCurSpdLim(void) {
 603:Src/util.c    ****   calcAvgSpeed();
 604:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 605:Src/util.c    ****     return;
 606:Src/util.c    ****   }
 607:Src/util.c    **** 
 608:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 609:Src/util.c    **** 
 610:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /tmp/ccNyZSr4.s 			page 23


 611:Src/util.c    ****   printf("Torque and Speed limits update started...\r\n");
 612:Src/util.c    ****   #endif
 613:Src/util.c    **** 
 614:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 615:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 616:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 617:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 618:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 619:Src/util.c    ****   cur_spd_valid = 0;
 620:Src/util.c    **** 
 621:Src/util.c    ****   // Wait for the power button press
 622:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec timeo
 623:Src/util.c    ****     readInputRaw();
 624:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 625:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 626:Src/util.c    ****     HAL_Delay(5);
 627:Src/util.c    ****   }
 628:Src/util.c    ****   // Calculate scaling factors
 629:Src/util.c    ****   cur_factor = CLAMP((input1_fixdt - (input1[inIdx].min << 16)) / (input1[inIdx].max - input1[inIdx
 630:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 631:Src/util.c    ****       
 632:Src/util.c    ****   if (input1[inIdx].typ != 0){
 633:Src/util.c    ****     // Update current limit
 634:Src/util.c    ****     rtP_Left.i_max = rtP_Right.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    
 635:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 636:Src/util.c    ****   }
 637:Src/util.c    **** 
 638:Src/util.c    ****   if (input2[inIdx].typ != 0){
 639:Src/util.c    ****     // Update speed limit
 640:Src/util.c    ****     rtP_Left.n_max = rtP_Right.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 
 641:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 642:Src/util.c    ****   }
 643:Src/util.c    **** 
 644:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 645:Src/util.c    ****   // cur_spd_valid: 0 = No limit changed, 1 = Current limit changed, 2 = Speed limit changed, 3 = B
 646:Src/util.c    ****   printf("Limits (%i)\r\nCurrent: fixdt:%li factor%i i_max:%i \r\nSpeed: fixdt:%li factor:%i n_max:
 647:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 648:Src/util.c    ****   #endif
 649:Src/util.c    **** 
 650:Src/util.c    **** #endif
 651:Src/util.c    **** }
 652:Src/util.c    **** 
 653:Src/util.c    ****  /*
 654:Src/util.c    ****  * Standstill Hold Function
 655:Src/util.c    ****  * This function uses Cruise Control to provide an anti-roll functionality at standstill.
 656:Src/util.c    ****  * Only available and makes sense for FOC VOLTAGE or FOC TORQUE mode.
 657:Src/util.c    ****  * 
 658:Src/util.c    ****  * Input:  none
 659:Src/util.c    ****  * Output: standstillAcv
 660:Src/util.c    ****  */
 661:Src/util.c    **** void standstillHold(void) {
 640              		.loc 1 661 27 view -0
 641              		.cfi_startproc
 642              		@ args = 0, pretend = 0, frame = 0
 643              		@ frame_needed = 0, uses_anonymous_args = 0
 644              		@ link register save eliminated.
 662:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
ARM GAS  /tmp/ccNyZSr4.s 			page 24


 663:Src/util.c    ****     if (!rtP_Left.b_cruiseCtrlEna) {                                  // If Stanstill in NOT Active
 664:Src/util.c    ****       if (((input1[inIdx].cmd > 50 || input2[inIdx].cmd < -50) && speedAvgAbs < 30) // Check if Bra
 665:Src/util.c    ****           || (input2[inIdx].cmd < 20 && speedAvgAbs < 5)) {           // OR Throttle is small AND m
 666:Src/util.c    ****         rtP_Left.n_cruiseMotTgt   = 0;
 667:Src/util.c    ****         rtP_Right.n_cruiseMotTgt  = 0;
 668:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 1;
 669:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 1;
 670:Src/util.c    ****         standstillAcv = 1;
 671:Src/util.c    ****       } 
 672:Src/util.c    ****     }
 673:Src/util.c    ****     else {                                                            // If Stanstill is Active -> 
 674:Src/util.c    ****       if (input1[inIdx].cmd < 20 && input2[inIdx].cmd > 50 && !cruiseCtrlAcv) { // Check if Brake i
 675:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 0;
 676:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 0;
 677:Src/util.c    ****         standstillAcv = 0;
 678:Src/util.c    ****       }
 679:Src/util.c    ****     }
 680:Src/util.c    ****   #endif
 681:Src/util.c    **** }
 645              		.loc 1 681 1 view .LVU158
 646 0000 7047     		bx	lr
 647              		.cfi_endproc
 648              	.LFE78:
 650              		.section	.text.electricBrake,"ax",%progbits
 651              		.align	1
 652              		.global	electricBrake
 653              		.syntax unified
 654              		.thumb
 655              		.thumb_func
 656              		.fpu softvfp
 658              	electricBrake:
 659              	.LVL32:
 660              	.LFB79:
 682:Src/util.c    **** 
 683:Src/util.c    ****  /*
 684:Src/util.c    ****  * Electric Brake Function
 685:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 686:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 687:Src/util.c    ****  * 
 688:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 689:Src/util.c    ****  * Output: input2.cmd (Throtle) with brake component included
 690:Src/util.c    ****  */
 691:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 661              		.loc 1 691 61 view -0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 0
 664              		@ frame_needed = 0, uses_anonymous_args = 0
 665              		@ link register save eliminated.
 692:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 693:Src/util.c    ****     int16_t brakeVal;
 694:Src/util.c    **** 
 695:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 696:Src/util.c    ****     if (speedAvg > 0) {
 697:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 698:Src/util.c    ****     } else {
 699:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 700:Src/util.c    ****     }
ARM GAS  /tmp/ccNyZSr4.s 			page 25


 701:Src/util.c    **** 
 702:Src/util.c    ****     // Check if direction is reversed
 703:Src/util.c    ****     if (reverseDir) {
 704:Src/util.c    ****       brakeVal = -brakeVal;
 705:Src/util.c    ****     }
 706:Src/util.c    **** 
 707:Src/util.c    ****     // Calculate the new input2.cmd with brake component included
 708:Src/util.c    ****     if (input2[inIdx].cmd >= 0 && input2[inIdx].cmd < ELECTRIC_BRAKE_THRES) {
 709:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - input2[inIdx].cmd) * brakeVal) / E
 710:Src/util.c    ****     } else if (input2[inIdx].cmd >= -ELECTRIC_BRAKE_THRES && input2[inIdx].cmd < 0) {
 711:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + input2[inIdx].cmd) * brakeVal) / E
 712:Src/util.c    ****     } else if (input2[inIdx].cmd >= ELECTRIC_BRAKE_THRES) {
 713:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((input2[inIdx].cmd - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / 
 714:Src/util.c    ****     } else {  // when (input2.cmd < -ELECTRIC_BRAKE_THRES)
 715:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((input2[inIdx].cmd + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / 
 716:Src/util.c    ****     }
 717:Src/util.c    ****   #endif
 718:Src/util.c    **** }
 666              		.loc 1 718 1 view .LVU160
 667 0000 7047     		bx	lr
 668              		.cfi_endproc
 669              	.LFE79:
 671              		.section	.text.cruiseControl,"ax",%progbits
 672              		.align	1
 673              		.global	cruiseControl
 674              		.syntax unified
 675              		.thumb
 676              		.thumb_func
 677              		.fpu softvfp
 679              	cruiseControl:
 680              	.LVL33:
 681              	.LFB80:
 719:Src/util.c    **** 
 720:Src/util.c    ****  /*
 721:Src/util.c    ****  * Cruise Control Function
 722:Src/util.c    ****  * This function activates/deactivates cruise control.
 723:Src/util.c    ****  * 
 724:Src/util.c    ****  * Input: button (as a pulse)
 725:Src/util.c    ****  * Output: cruiseCtrlAcv
 726:Src/util.c    ****  */
 727:Src/util.c    **** void cruiseControl(uint8_t button) {
 682              		.loc 1 727 36 view -0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 0
 685              		@ frame_needed = 0, uses_anonymous_args = 0
 686              		@ link register save eliminated.
 728:Src/util.c    ****   #ifdef CRUISE_CONTROL_SUPPORT
 729:Src/util.c    ****     if (button && !rtP_Left.b_cruiseCtrlEna) {                          // Cruise control activated
 730:Src/util.c    ****       rtP_Left.n_cruiseMotTgt   = rtY_Left.n_mot;
 731:Src/util.c    ****       rtP_Right.n_cruiseMotTgt  = rtY_Right.n_mot;
 732:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 1;
 733:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 1;
 734:Src/util.c    ****       cruiseCtrlAcv = 1;
 735:Src/util.c    ****       beepShortMany(2, 1);                                              // 200 ms beep delay. Acts 
 736:Src/util.c    ****     } else if (button && rtP_Left.b_cruiseCtrlEna && !standstillAcv) {  // Cruise control deactivat
 737:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 0;
 738:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 0;
ARM GAS  /tmp/ccNyZSr4.s 			page 26


 739:Src/util.c    ****       cruiseCtrlAcv = 0;
 740:Src/util.c    ****       beepShortMany(2, -1);
 741:Src/util.c    ****     }
 742:Src/util.c    ****   #endif
 743:Src/util.c    **** }
 687              		.loc 1 743 1 view .LVU162
 688 0000 7047     		bx	lr
 689              		.cfi_endproc
 690              	.LFE80:
 692              		.section	.text.checkInputType,"ax",%progbits
 693              		.align	1
 694              		.global	checkInputType
 695              		.syntax unified
 696              		.thumb
 697              		.thumb_func
 698              		.fpu softvfp
 700              	checkInputType:
 701              	.LVL34:
 702              	.LFB81:
 744:Src/util.c    **** 
 745:Src/util.c    ****  /*
 746:Src/util.c    ****  * Check Input Type
 747:Src/util.c    ****  * This function identifies the input type: 0: Disabled, 1: Normal Pot, 2: Middle Resting Pot
 748:Src/util.c    ****  */
 749:Src/util.c    **** int checkInputType(int16_t min, int16_t mid, int16_t max){
 703              		.loc 1 749 58 view -0
 704              		.cfi_startproc
 705              		@ args = 0, pretend = 0, frame = 0
 706              		@ frame_needed = 0, uses_anonymous_args = 0
 707              		.loc 1 749 58 is_stmt 0 view .LVU164
 708 0000 70B5     		push	{r4, r5, r6, lr}
 709              	.LCFI6:
 710              		.cfi_def_cfa_offset 16
 711              		.cfi_offset 4, -16
 712              		.cfi_offset 5, -12
 713              		.cfi_offset 6, -8
 714              		.cfi_offset 14, -4
 750:Src/util.c    **** 
 751:Src/util.c    ****   int type = 0;  
 715              		.loc 1 751 3 is_stmt 1 view .LVU165
 716              	.LVL35:
 752:Src/util.c    ****   #ifdef CONTROL_ADC
 753:Src/util.c    ****   int16_t threshold = 400;      // Threshold to define if values are too close
 717              		.loc 1 753 3 view .LVU166
 754:Src/util.c    ****   #else
 755:Src/util.c    ****   int16_t threshold = 200;
 756:Src/util.c    ****   #endif
 757:Src/util.c    **** 
 758:Src/util.c    ****   if ((min / threshold) == (max / threshold) || (mid / threshold) == (max / threshold) || min > max
 718              		.loc 1 758 3 view .LVU167
 719              		.loc 1 758 12 is_stmt 0 view .LVU168
 720 0002 184B     		ldr	r3, .L58
 721 0004 83FB0054 		smull	r5, r4, r3, r0
 722 0008 C517     		asrs	r5, r0, #31
 723 000a C5EBE415 		rsb	r5, r5, r4, asr #7
 724              		.loc 1 758 33 view .LVU169
 725 000e 83FB0243 		smull	r4, r3, r3, r2
ARM GAS  /tmp/ccNyZSr4.s 			page 27


 726 0012 D417     		asrs	r4, r2, #31
 727 0014 C4EBE313 		rsb	r3, r4, r3, asr #7
 728              		.loc 1 758 6 view .LVU170
 729 0018 9D42     		cmp	r5, r3
 730 001a 1AD0     		beq	.L51
 731              		.loc 1 758 54 discriminator 1 view .LVU171
 732 001c 114E     		ldr	r6, .L58
 733 001e 86FB0146 		smull	r4, r6, r6, r1
 734 0022 CC17     		asrs	r4, r1, #31
 735 0024 C4EBE614 		rsb	r4, r4, r6, asr #7
 736              		.loc 1 758 46 discriminator 1 view .LVU172
 737 0028 A342     		cmp	r3, r4
 738 002a 15D0     		beq	.L52
 739              		.loc 1 758 88 discriminator 2 view .LVU173
 740 002c 9042     		cmp	r0, r2
 741 002e 15DC     		bgt	.L53
 742              		.loc 1 758 101 discriminator 3 view .LVU174
 743 0030 8A42     		cmp	r2, r1
 744 0032 15DB     		blt	.L54
 759:Src/util.c    ****     type = 0;
 760:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 761:Src/util.c    ****     printf("ignored");                // (MIN and MAX) OR (MID and MAX) are close, disable input
 762:Src/util.c    ****     #endif
 763:Src/util.c    ****   } else {
 764:Src/util.c    ****     if ((min / threshold) == (mid / threshold)){
 745              		.loc 1 764 5 is_stmt 1 view .LVU175
 746              		.loc 1 764 8 is_stmt 0 view .LVU176
 747 0034 A542     		cmp	r5, r4
 748 0036 0AD0     		beq	.L57
 765:Src/util.c    ****       type = 1;
 766:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 767:Src/util.c    ****       printf("a normal pot");        // MIN and MID are close, it's a normal pot
 768:Src/util.c    ****       #endif
 769:Src/util.c    ****     } else {
 770:Src/util.c    ****       type = 2;
 749              		.loc 1 770 12 view .LVU177
 750 0038 0224     		movs	r4, #2
 751              	.L50:
 752              	.LVL36:
 771:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 772:Src/util.c    ****       printf("a mid-resting pot");   // it's a mid resting pot
 773:Src/util.c    ****       #endif
 774:Src/util.c    ****     }
 775:Src/util.c    **** 
 776:Src/util.c    ****     #ifdef CONTROL_ADC
 777:Src/util.c    ****     if ((min + ADC_MARGIN - ADC_PROTECT_THRESH) > 0 && (max - ADC_MARGIN + ADC_PROTECT_THRESH) < 40
 753              		.loc 1 777 5 is_stmt 1 view .LVU178
 754              		.loc 1 777 8 is_stmt 0 view .LVU179
 755 003a 6428     		cmp	r0, #100
 756 003c 0ADD     		ble	.L48
 757              		.loc 1 777 53 discriminator 1 view .LVU180
 758 003e 40F69A73 		movw	r3, #3994
 759 0042 9A42     		cmp	r2, r3
 760 0044 06DC     		bgt	.L48
 778:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 779:Src/util.c    ****       printf(" AND protected");
 780:Src/util.c    ****       #endif
ARM GAS  /tmp/ccNyZSr4.s 			page 28


 781:Src/util.c    ****       beepLong(2); // Indicate protection by a beep
 761              		.loc 1 781 7 is_stmt 1 view .LVU181
 762 0046 0220     		movs	r0, #2
 763              	.LVL37:
 764              		.loc 1 781 7 is_stmt 0 view .LVU182
 765 0048 FFF7FEFF 		bl	beepLong
 766              	.LVL38:
 767              		.loc 1 781 7 view .LVU183
 768 004c 02E0     		b	.L48
 769              	.LVL39:
 770              	.L57:
 765:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 771              		.loc 1 765 12 view .LVU184
 772 004e 0124     		movs	r4, #1
 773 0050 F3E7     		b	.L50
 774              	.L51:
 759:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 775              		.loc 1 759 10 view .LVU185
 776 0052 0024     		movs	r4, #0
 777              	.LVL40:
 778              	.L48:
 782:Src/util.c    ****     }
 783:Src/util.c    ****     #endif
 784:Src/util.c    ****   }
 785:Src/util.c    **** 
 786:Src/util.c    ****   return type;
 787:Src/util.c    **** }
 779              		.loc 1 787 1 view .LVU186
 780 0054 2046     		mov	r0, r4
 781 0056 70BD     		pop	{r4, r5, r6, pc}
 782              	.LVL41:
 783              	.L52:
 759:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 784              		.loc 1 759 10 view .LVU187
 785 0058 0024     		movs	r4, #0
 786 005a FBE7     		b	.L48
 787              	.L53:
 788 005c 0024     		movs	r4, #0
 789 005e F9E7     		b	.L48
 790              	.L54:
 791 0060 0024     		movs	r4, #0
 786:Src/util.c    **** }
 792              		.loc 1 786 3 is_stmt 1 view .LVU188
 786:Src/util.c    **** }
 793              		.loc 1 786 10 is_stmt 0 view .LVU189
 794 0062 F7E7     		b	.L48
 795              	.L59:
 796              		.align	2
 797              	.L58:
 798 0064 1F85EB51 		.word	1374389535
 799              		.cfi_endproc
 800              	.LFE81:
 802              		.section	.text.Input_Init,"ax",%progbits
 803              		.align	1
 804              		.global	Input_Init
 805              		.syntax unified
 806              		.thumb
ARM GAS  /tmp/ccNyZSr4.s 			page 29


 807              		.thumb_func
 808              		.fpu softvfp
 810              	Input_Init:
 811              	.LFB68:
 285:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 812              		.loc 1 285 23 is_stmt 1 view -0
 813              		.cfi_startproc
 814              		@ args = 0, pretend = 0, frame = 8
 815              		@ frame_needed = 0, uses_anonymous_args = 0
 816 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 817              	.LCFI7:
 818              		.cfi_def_cfa_offset 28
 819              		.cfi_offset 4, -28
 820              		.cfi_offset 5, -24
 821              		.cfi_offset 6, -20
 822              		.cfi_offset 7, -16
 823              		.cfi_offset 8, -12
 824              		.cfi_offset 9, -8
 825              		.cfi_offset 14, -4
 826 0004 83B0     		sub	sp, sp, #12
 827              	.LCFI8:
 828              		.cfi_def_cfa_offset 40
 315:Src/util.c    ****     HAL_FLASH_Unlock();
 829              		.loc 1 315 5 view .LVU191
 316:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 830              		.loc 1 316 5 view .LVU192
 831 0006 FFF7FEFF 		bl	HAL_FLASH_Unlock
 832              	.LVL42:
 317:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 833              		.loc 1 317 5 view .LVU193
 834 000a FFF7FEFF 		bl	EE_Init
 835              	.LVL43:
 318:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 836              		.loc 1 318 5 view .LVU194
 837 000e 0DF10601 		add	r1, sp, #6
 838 0012 644B     		ldr	r3, .L75
 839 0014 1888     		ldrh	r0, [r3]
 840 0016 FFF7FEFF 		bl	EE_ReadVariable
 841              	.LVL44:
 319:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 842              		.loc 1 319 5 view .LVU195
 319:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 843              		.loc 1 319 20 is_stmt 0 view .LVU196
 844 001a BDF80620 		ldrh	r2, [sp, #6]
 319:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 845              		.loc 1 319 8 view .LVU197
 846 001e 41F20713 		movw	r3, #4359
 847 0022 9A42     		cmp	r2, r3
 848 0024 07D0     		beq	.L72
 849              	.LBB5:
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 850              		.loc 1 333 20 view .LVU198
 851 0026 0024     		movs	r4, #0
 852              	.L61:
 853              	.LVL45:
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 854              		.loc 1 333 25 is_stmt 1 discriminator 1 view .LVU199
ARM GAS  /tmp/ccNyZSr4.s 			page 30


 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 855              		.loc 1 333 7 is_stmt 0 discriminator 1 view .LVU200
 856 0028 002C     		cmp	r4, #0
 857 002a 79D0     		beq	.L69
 858              	.LVL46:
 859              	.L64:
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 860              		.loc 1 333 7 discriminator 1 view .LVU201
 861              	.LBE5:
 346:Src/util.c    ****   #endif
 862              		.loc 1 346 5 is_stmt 1 view .LVU202
 863 002c FFF7FEFF 		bl	HAL_FLASH_Lock
 864              	.LVL47:
 398:Src/util.c    **** 
 865              		.loc 1 398 1 is_stmt 0 view .LVU203
 866 0030 03B0     		add	sp, sp, #12
 867              	.LCFI9:
 868              		.cfi_remember_state
 869              		.cfi_def_cfa_offset 28
 870              		@ sp needed
 871 0032 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 872              	.L72:
 873              	.LCFI10:
 874              		.cfi_restore_state
 320:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 875              		.loc 1 320 7 is_stmt 1 view .LVU204
 876 0036 5B4E     		ldr	r6, .L75
 877 0038 01A9     		add	r1, sp, #4
 878 003a 7088     		ldrh	r0, [r6, #2]
 879 003c FFF7FEFF 		bl	EE_ReadVariable
 880              	.LVL48:
 320:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 881              		.loc 1 320 53 view .LVU205
 320:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 882              		.loc 1 320 88 is_stmt 0 view .LVU206
 883 0040 BDF90430 		ldrsh	r3, [sp, #4]
 320:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 884              		.loc 1 320 86 view .LVU207
 885 0044 584D     		ldr	r5, .L75+4
 886 0046 A5F8CE30 		strh	r3, [r5, #206]	@ movhi
 320:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 887              		.loc 1 320 68 view .LVU208
 888 004a 584C     		ldr	r4, .L75+8
 889 004c A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 321:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 890              		.loc 1 321 7 is_stmt 1 view .LVU209
 891 0050 01A9     		add	r1, sp, #4
 892 0052 B088     		ldrh	r0, [r6, #4]
 893 0054 FFF7FEFF 		bl	EE_ReadVariable
 894              	.LVL49:
 321:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 895              		.loc 1 321 53 view .LVU210
 321:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 896              		.loc 1 321 88 is_stmt 0 view .LVU211
 897 0058 BDF90430 		ldrsh	r3, [sp, #4]
 321:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 898              		.loc 1 321 86 view .LVU212
ARM GAS  /tmp/ccNyZSr4.s 			page 31


 899 005c A5F8DA30 		strh	r3, [r5, #218]	@ movhi
 321:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 900              		.loc 1 321 68 view .LVU213
 901 0060 A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 902              		.loc 1 322 7 is_stmt 1 view .LVU214
 903              	.LBB6:
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 904              		.loc 1 322 12 view .LVU215
 905              	.LVL50:
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 906              		.loc 1 322 20 is_stmt 0 view .LVU216
 907 0064 0025     		movs	r5, #0
 908              	.LVL51:
 909              	.L62:
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 910              		.loc 1 322 25 is_stmt 1 discriminator 1 view .LVU217
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 911              		.loc 1 322 7 is_stmt 0 discriminator 1 view .LVU218
 912 0066 002D     		cmp	r5, #0
 913 0068 E0D1     		bne	.L64
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 914              		.loc 1 323 9 is_stmt 1 discriminator 3 view .LVU219
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 915              		.loc 1 323 43 is_stmt 0 discriminator 3 view .LVU220
 916 006a EC00     		lsls	r4, r5, #3
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 917              		.loc 1 323 41 discriminator 3 view .LVU221
 918 006c E31C     		adds	r3, r4, #3
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 919              		.loc 1 323 9 discriminator 3 view .LVU222
 920 006e 4D4E     		ldr	r6, .L75
 921 0070 01A9     		add	r1, sp, #4
 922 0072 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 923 0076 FFF7FEFF 		bl	EE_ReadVariable
 924              	.LVL52:
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 925              		.loc 1 323 60 is_stmt 1 discriminator 3 view .LVU223
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 926              		.loc 1 323 76 is_stmt 0 discriminator 3 view .LVU224
 927 007a 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 323:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 928              		.loc 1 323 74 discriminator 3 view .LVU225
 929 007e 621B     		subs	r2, r4, r5
 930 0080 4B4F     		ldr	r7, .L75+12
 931 0082 07EB4207 		add	r7, r7, r2, lsl #1
 932 0086 3B71     		strb	r3, [r7, #4]
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 933              		.loc 1 324 9 is_stmt 1 discriminator 3 view .LVU226
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 934              		.loc 1 324 41 is_stmt 0 discriminator 3 view .LVU227
 935 0088 231D     		adds	r3, r4, #4
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 936              		.loc 1 324 9 discriminator 3 view .LVU228
 937 008a 01A9     		add	r1, sp, #4
 938 008c 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 939 0090 FFF7FEFF 		bl	EE_ReadVariable
ARM GAS  /tmp/ccNyZSr4.s 			page 32


 940              	.LVL53:
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 941              		.loc 1 324 60 is_stmt 1 discriminator 3 view .LVU229
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 942              		.loc 1 324 76 is_stmt 0 discriminator 3 view .LVU230
 943 0094 BDF90430 		ldrsh	r3, [sp, #4]
 324:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 944              		.loc 1 324 74 discriminator 3 view .LVU231
 945 0098 FB80     		strh	r3, [r7, #6]	@ movhi
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 946              		.loc 1 325 9 is_stmt 1 discriminator 3 view .LVU232
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 947              		.loc 1 325 41 is_stmt 0 discriminator 3 view .LVU233
 948 009a 631D     		adds	r3, r4, #5
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 949              		.loc 1 325 9 discriminator 3 view .LVU234
 950 009c 01A9     		add	r1, sp, #4
 951 009e 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 952 00a2 FFF7FEFF 		bl	EE_ReadVariable
 953              	.LVL54:
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 954              		.loc 1 325 60 is_stmt 1 discriminator 3 view .LVU235
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 955              		.loc 1 325 76 is_stmt 0 discriminator 3 view .LVU236
 956 00a6 BDF90430 		ldrsh	r3, [sp, #4]
 325:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 957              		.loc 1 325 74 discriminator 3 view .LVU237
 958 00aa 3B81     		strh	r3, [r7, #8]	@ movhi
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 959              		.loc 1 326 9 is_stmt 1 discriminator 3 view .LVU238
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 960              		.loc 1 326 41 is_stmt 0 discriminator 3 view .LVU239
 961 00ac A31D     		adds	r3, r4, #6
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 962              		.loc 1 326 9 discriminator 3 view .LVU240
 963 00ae 01A9     		add	r1, sp, #4
 964 00b0 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 965 00b4 FFF7FEFF 		bl	EE_ReadVariable
 966              	.LVL55:
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 967              		.loc 1 326 60 is_stmt 1 discriminator 3 view .LVU241
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 968              		.loc 1 326 76 is_stmt 0 discriminator 3 view .LVU242
 969 00b8 BDF90430 		ldrsh	r3, [sp, #4]
 326:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 970              		.loc 1 326 74 discriminator 3 view .LVU243
 971 00bc 7B81     		strh	r3, [r7, #10]	@ movhi
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 972              		.loc 1 327 9 is_stmt 1 discriminator 3 view .LVU244
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 973              		.loc 1 327 41 is_stmt 0 discriminator 3 view .LVU245
 974 00be E31D     		adds	r3, r4, #7
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 975              		.loc 1 327 9 discriminator 3 view .LVU246
 976 00c0 01A9     		add	r1, sp, #4
 977 00c2 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 978 00c6 FFF7FEFF 		bl	EE_ReadVariable
ARM GAS  /tmp/ccNyZSr4.s 			page 33


 979              	.LVL56:
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 980              		.loc 1 327 60 is_stmt 1 discriminator 3 view .LVU247
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 981              		.loc 1 327 76 is_stmt 0 discriminator 3 view .LVU248
 982 00ca 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 327:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 983              		.loc 1 327 74 discriminator 3 view .LVU249
 984 00ce DFF8E480 		ldr	r8, .L75+16
 985 00d2 671B     		subs	r7, r4, r5
 986 00d4 08EB4707 		add	r7, r8, r7, lsl #1
 987 00d8 3B71     		strb	r3, [r7, #4]
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 988              		.loc 1 328 9 is_stmt 1 discriminator 3 view .LVU250
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 989              		.loc 1 328 41 is_stmt 0 discriminator 3 view .LVU251
 990 00da 05F10109 		add	r9, r5, #1
 991 00de 4FEAC903 		lsl	r3, r9, #3
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 992              		.loc 1 328 9 discriminator 3 view .LVU252
 993 00e2 01A9     		add	r1, sp, #4
 994 00e4 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 995 00e8 FFF7FEFF 		bl	EE_ReadVariable
 996              	.LVL57:
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 997              		.loc 1 328 60 is_stmt 1 discriminator 3 view .LVU253
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 998              		.loc 1 328 76 is_stmt 0 discriminator 3 view .LVU254
 999 00ec BDF90430 		ldrsh	r3, [sp, #4]
 328:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 1000              		.loc 1 328 74 discriminator 3 view .LVU255
 1001 00f0 FB80     		strh	r3, [r7, #6]	@ movhi
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1002              		.loc 1 329 9 is_stmt 1 discriminator 3 view .LVU256
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1003              		.loc 1 329 41 is_stmt 0 discriminator 3 view .LVU257
 1004 00f2 04F10903 		add	r3, r4, #9
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1005              		.loc 1 329 9 discriminator 3 view .LVU258
 1006 00f6 01A9     		add	r1, sp, #4
 1007 00f8 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1008 00fc FFF7FEFF 		bl	EE_ReadVariable
 1009              	.LVL58:
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1010              		.loc 1 329 60 is_stmt 1 discriminator 3 view .LVU259
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1011              		.loc 1 329 76 is_stmt 0 discriminator 3 view .LVU260
 1012 0100 BDF90430 		ldrsh	r3, [sp, #4]
 329:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 1013              		.loc 1 329 74 discriminator 3 view .LVU261
 1014 0104 3B81     		strh	r3, [r7, #8]	@ movhi
 330:Src/util.c    ****       }
 1015              		.loc 1 330 9 is_stmt 1 discriminator 3 view .LVU262
 330:Src/util.c    ****       }
 1016              		.loc 1 330 41 is_stmt 0 discriminator 3 view .LVU263
 1017 0106 04F10A03 		add	r3, r4, #10
 330:Src/util.c    ****       }
ARM GAS  /tmp/ccNyZSr4.s 			page 34


 1018              		.loc 1 330 9 discriminator 3 view .LVU264
 1019 010a 01A9     		add	r1, sp, #4
 1020 010c 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1021 0110 FFF7FEFF 		bl	EE_ReadVariable
 1022              	.LVL59:
 330:Src/util.c    ****       }
 1023              		.loc 1 330 60 is_stmt 1 discriminator 3 view .LVU265
 330:Src/util.c    ****       }
 1024              		.loc 1 330 76 is_stmt 0 discriminator 3 view .LVU266
 1025 0114 BDF90430 		ldrsh	r3, [sp, #4]
 330:Src/util.c    ****       }
 1026              		.loc 1 330 74 discriminator 3 view .LVU267
 1027 0118 7B81     		strh	r3, [r7, #10]	@ movhi
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1028              		.loc 1 322 38 is_stmt 1 discriminator 3 view .LVU268
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1029              		.loc 1 322 39 is_stmt 0 discriminator 3 view .LVU269
 1030 011a 5FFA89F5 		uxtb	r5, r9
 1031              	.LVL60:
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1032              		.loc 1 322 39 discriminator 3 view .LVU270
 1033 011e A2E7     		b	.L62
 1034              	.LVL61:
 1035              	.L69:
 322:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1036              		.loc 1 322 39 discriminator 3 view .LVU271
 1037              	.LBE6:
 1038              	.LBB7:
 334:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1039              		.loc 1 334 9 is_stmt 1 view .LVU272
 334:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1040              		.loc 1 334 22 is_stmt 0 view .LVU273
 1041 0120 2546     		mov	r5, r4
 1042 0122 C4EBC403 		rsb	r3, r4, r4, lsl #3
 1043 0126 224A     		ldr	r2, .L75+12
 1044 0128 02EB4303 		add	r3, r2, r3, lsl #1
 1045 012c 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 334:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1046              		.loc 1 334 12 view .LVU274
 1047 012e 0329     		cmp	r1, #3
 1048 0130 16D0     		beq	.L73
 337:Src/util.c    ****         }
 1049              		.loc 1 337 11 is_stmt 1 view .LVU275
 337:Src/util.c    ****         }
 1050              		.loc 1 337 25 is_stmt 0 view .LVU276
 1051 0132 C4EBC403 		rsb	r3, r4, r4, lsl #3
 1052 0136 1E4A     		ldr	r2, .L75+12
 1053 0138 02EB4303 		add	r3, r2, r3, lsl #1
 1054 013c 1971     		strb	r1, [r3, #4]
 1055              	.L66:
 339:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1056              		.loc 1 339 9 is_stmt 1 view .LVU277
 339:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1057              		.loc 1 339 22 is_stmt 0 view .LVU278
 1058 013e C5EBC503 		rsb	r3, r5, r5, lsl #3
 1059 0142 1C4A     		ldr	r2, .L75+16
 1060 0144 02EB4303 		add	r3, r2, r3, lsl #1
ARM GAS  /tmp/ccNyZSr4.s 			page 35


 1061 0148 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 339:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1062              		.loc 1 339 12 view .LVU279
 1063 014a 032A     		cmp	r2, #3
 1064 014c 16D0     		beq	.L74
 342:Src/util.c    ****         }
 1065              		.loc 1 342 11 is_stmt 1 view .LVU280
 342:Src/util.c    ****         }
 1066              		.loc 1 342 25 is_stmt 0 view .LVU281
 1067 014e C5EBC505 		rsb	r5, r5, r5, lsl #3
 1068 0152 184B     		ldr	r3, .L75+16
 1069 0154 03EB4505 		add	r5, r3, r5, lsl #1
 1070 0158 2A71     		strb	r2, [r5, #4]
 1071              	.L68:
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1072              		.loc 1 333 38 is_stmt 1 discriminator 2 view .LVU282
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1073              		.loc 1 333 39 is_stmt 0 discriminator 2 view .LVU283
 1074 015a 0134     		adds	r4, r4, #1
 1075              	.LVL62:
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1076              		.loc 1 333 39 discriminator 2 view .LVU284
 1077 015c E4B2     		uxtb	r4, r4
 1078              	.LVL63:
 333:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1079              		.loc 1 333 39 discriminator 2 view .LVU285
 1080 015e 63E7     		b	.L61
 1081              	.L73:
 335:Src/util.c    ****         } else {
 1082              		.loc 1 335 11 is_stmt 1 view .LVU286
 335:Src/util.c    ****         } else {
 1083              		.loc 1 335 27 is_stmt 0 view .LVU287
 1084 0160 C4EBC406 		rsb	r6, r4, r4, lsl #3
 1085 0164 02EB4606 		add	r6, r2, r6, lsl #1
 1086 0168 B6F90A20 		ldrsh	r2, [r6, #10]
 1087 016c B6F90810 		ldrsh	r1, [r6, #8]
 1088 0170 B6F90600 		ldrsh	r0, [r6, #6]
 1089 0174 FFF7FEFF 		bl	checkInputType
 1090              	.LVL64:
 335:Src/util.c    ****         } else {
 1091              		.loc 1 335 25 view .LVU288
 1092 0178 3071     		strb	r0, [r6, #4]
 1093 017a E0E7     		b	.L66
 1094              	.L74:
 340:Src/util.c    ****         } else {
 1095              		.loc 1 340 11 is_stmt 1 view .LVU289
 340:Src/util.c    ****         } else {
 1096              		.loc 1 340 27 is_stmt 0 view .LVU290
 1097 017c 0D4E     		ldr	r6, .L75+16
 1098 017e EF00     		lsls	r7, r5, #3
 1099 0180 C5EBC503 		rsb	r3, r5, r5, lsl #3
 1100 0184 06EB4303 		add	r3, r6, r3, lsl #1
 1101 0188 B3F90A20 		ldrsh	r2, [r3, #10]
 1102 018c B3F90810 		ldrsh	r1, [r3, #8]
 1103 0190 B3F90600 		ldrsh	r0, [r3, #6]
 1104 0194 FFF7FEFF 		bl	checkInputType
 1105              	.LVL65:
ARM GAS  /tmp/ccNyZSr4.s 			page 36


 340:Src/util.c    ****         } else {
 1106              		.loc 1 340 25 view .LVU291
 1107 0198 7D1B     		subs	r5, r7, r5
 1108 019a 06EB4506 		add	r6, r6, r5, lsl #1
 1109 019e 3071     		strb	r0, [r6, #4]
 1110 01a0 DBE7     		b	.L68
 1111              	.L76:
 1112 01a2 00BF     		.align	2
 1113              	.L75:
 1114 01a4 00000000 		.word	.LANCHOR2
 1115 01a8 00000000 		.word	rtP_Right
 1116 01ac 00000000 		.word	rtP_Left
 1117 01b0 00000000 		.word	.LANCHOR3
 1118 01b4 00000000 		.word	.LANCHOR4
 1119              	.LBE7:
 1120              		.cfi_endproc
 1121              	.LFE68:
 1123              		.section	.text.calcInputCmd,"ax",%progbits
 1124              		.align	1
 1125              		.global	calcInputCmd
 1126              		.syntax unified
 1127              		.thumb
 1128              		.thumb_func
 1129              		.fpu softvfp
 1131              	calcInputCmd:
 1132              	.LVL66:
 1133              	.LFB82:
 788:Src/util.c    **** 
 789:Src/util.c    **** 
 790:Src/util.c    **** 
 791:Src/util.c    **** /* =========================== Input Functions =========================== */
 792:Src/util.c    **** 
 793:Src/util.c    ****  /*
 794:Src/util.c    ****  * Calculate Input Command
 795:Src/util.c    ****  * This function realizes dead-band around 0 and scales the input between [out_min, out_max]
 796:Src/util.c    ****  */
 797:Src/util.c    **** void calcInputCmd(InputStruct *in, int16_t out_min, int16_t out_max) {
 1134              		.loc 1 797 70 is_stmt 1 view -0
 1135              		.cfi_startproc
 1136              		@ args = 0, pretend = 0, frame = 0
 1137              		@ frame_needed = 0, uses_anonymous_args = 0
 1138              		@ link register save eliminated.
 1139              		.loc 1 797 70 is_stmt 0 view .LVU293
 1140 0000 F0B4     		push	{r4, r5, r6, r7}
 1141              	.LCFI11:
 1142              		.cfi_def_cfa_offset 16
 1143              		.cfi_offset 4, -16
 1144              		.cfi_offset 5, -12
 1145              		.cfi_offset 6, -8
 1146              		.cfi_offset 7, -4
 798:Src/util.c    ****   switch (in->typ){
 1147              		.loc 1 798 3 is_stmt 1 view .LVU294
 1148              		.loc 1 798 13 is_stmt 0 view .LVU295
 1149 0002 0479     		ldrb	r4, [r0, #4]	@ zero_extendqisi2
 1150              		.loc 1 798 3 view .LVU296
 1151 0004 012C     		cmp	r4, #1
 1152 0006 04D0     		beq	.L78
ARM GAS  /tmp/ccNyZSr4.s 			page 37


 1153 0008 022C     		cmp	r4, #2
 1154 000a 16D0     		beq	.L79
 799:Src/util.c    ****     case 1: // Input is a normal pot
 800:Src/util.c    ****       in->cmd = CLAMP(MAP(in->raw, in->min, in->max, 0, out_max), 0, out_max);
 801:Src/util.c    ****       break;
 802:Src/util.c    ****     case 2: // Input is a mid resting pot
 803:Src/util.c    ****       if( in->raw > in->mid - in->dband && in->raw < in->mid + in->dband ) {
 804:Src/util.c    ****         in->cmd = 0;
 805:Src/util.c    ****       } else if(in->raw > in->mid) {
 806:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 807:Src/util.c    ****       } else {
 808:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid - in->dband, in->min, 0, out_min), out_min, 0);
 809:Src/util.c    ****       }
 810:Src/util.c    ****       break;
 811:Src/util.c    ****     default: // Input is ignored
 812:Src/util.c    ****       in->cmd = 0;
 1155              		.loc 1 812 7 is_stmt 1 view .LVU297
 1156              		.loc 1 812 15 is_stmt 0 view .LVU298
 1157 000c 0023     		movs	r3, #0
 1158 000e 4380     		strh	r3, [r0, #2]	@ movhi
 813:Src/util.c    ****       break;
 1159              		.loc 1 813 7 is_stmt 1 view .LVU299
 814:Src/util.c    ****   }
 815:Src/util.c    **** }
 1160              		.loc 1 815 1 is_stmt 0 view .LVU300
 1161 0010 11E0     		b	.L77
 1162              	.L78:
 800:Src/util.c    ****       break;
 1163              		.loc 1 800 7 is_stmt 1 view .LVU301
 800:Src/util.c    ****       break;
 1164              		.loc 1 800 17 is_stmt 0 view .LVU302
 1165 0012 B0F90030 		ldrsh	r3, [r0]
 1166 0016 B0F90640 		ldrsh	r4, [r0, #6]
 1167 001a 1B1B     		subs	r3, r3, r4
 1168 001c 02FB03F3 		mul	r3, r2, r3
 1169 0020 B0F90A10 		ldrsh	r1, [r0, #10]
 1170              	.LVL67:
 800:Src/util.c    ****       break;
 1171              		.loc 1 800 17 view .LVU303
 1172 0024 091B     		subs	r1, r1, r4
 1173 0026 93FBF1F3 		sdiv	r3, r3, r1
 800:Src/util.c    ****       break;
 1174              		.loc 1 800 15 view .LVU304
 1175 002a 9A42     		cmp	r2, r3
 1176 002c 02DB     		blt	.L81
 800:Src/util.c    ****       break;
 1177              		.loc 1 800 17 discriminator 1 view .LVU305
 1178 002e 23EAE372 		bic	r2, r3, r3, asr #31
 1179              	.LVL68:
 800:Src/util.c    ****       break;
 1180              		.loc 1 800 15 discriminator 1 view .LVU306
 1181 0032 12B2     		sxth	r2, r2
 1182              	.L81:
 800:Src/util.c    ****       break;
 1183              		.loc 1 800 15 discriminator 4 view .LVU307
 1184 0034 4280     		strh	r2, [r0, #2]	@ movhi
 801:Src/util.c    ****     case 2: // Input is a mid resting pot
ARM GAS  /tmp/ccNyZSr4.s 			page 38


 1185              		.loc 1 801 7 is_stmt 1 discriminator 4 view .LVU308
 1186              	.L77:
 1187              		.loc 1 815 1 is_stmt 0 view .LVU309
 1188 0036 F0BC     		pop	{r4, r5, r6, r7}
 1189              	.LCFI12:
 1190              		.cfi_remember_state
 1191              		.cfi_restore 7
 1192              		.cfi_restore 6
 1193              		.cfi_restore 5
 1194              		.cfi_restore 4
 1195              		.cfi_def_cfa_offset 0
 1196 0038 7047     		bx	lr
 1197              	.LVL69:
 1198              	.L79:
 1199              	.LCFI13:
 1200              		.cfi_restore_state
 803:Src/util.c    ****         in->cmd = 0;
 1201              		.loc 1 803 7 is_stmt 1 view .LVU310
 803:Src/util.c    ****         in->cmd = 0;
 1202              		.loc 1 803 13 is_stmt 0 view .LVU311
 1203 003a B0F90030 		ldrsh	r3, [r0]
 803:Src/util.c    ****         in->cmd = 0;
 1204              		.loc 1 803 23 view .LVU312
 1205 003e B0F90840 		ldrsh	r4, [r0, #8]
 803:Src/util.c    ****         in->cmd = 0;
 1206              		.loc 1 803 33 view .LVU313
 1207 0042 B0F90C50 		ldrsh	r5, [r0, #12]
 803:Src/util.c    ****         in->cmd = 0;
 1208              		.loc 1 803 29 view .LVU314
 1209 0046 661B     		subs	r6, r4, r5
 803:Src/util.c    ****         in->cmd = 0;
 1210              		.loc 1 803 9 view .LVU315
 1211 0048 B342     		cmp	r3, r6
 1212 004a 05DD     		ble	.L83
 803:Src/util.c    ****         in->cmd = 0;
 1213              		.loc 1 803 62 discriminator 1 view .LVU316
 1214 004c 6719     		adds	r7, r4, r5
 803:Src/util.c    ****         in->cmd = 0;
 1215              		.loc 1 803 41 discriminator 1 view .LVU317
 1216 004e BB42     		cmp	r3, r7
 1217 0050 02DA     		bge	.L83
 804:Src/util.c    ****       } else if(in->raw > in->mid) {
 1218              		.loc 1 804 9 is_stmt 1 view .LVU318
 804:Src/util.c    ****       } else if(in->raw > in->mid) {
 1219              		.loc 1 804 17 is_stmt 0 view .LVU319
 1220 0052 0023     		movs	r3, #0
 1221 0054 4380     		strh	r3, [r0, #2]	@ movhi
 1222 0056 EEE7     		b	.L77
 1223              	.L83:
 805:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1224              		.loc 1 805 14 is_stmt 1 view .LVU320
 805:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1225              		.loc 1 805 16 is_stmt 0 view .LVU321
 1226 0058 A342     		cmp	r3, r4
 1227 005a 0FDD     		ble	.L84
 806:Src/util.c    ****       } else {
 1228              		.loc 1 806 9 is_stmt 1 view .LVU322
ARM GAS  /tmp/ccNyZSr4.s 			page 39


 806:Src/util.c    ****       } else {
 1229              		.loc 1 806 19 is_stmt 0 view .LVU323
 1230 005c 2C44     		add	r4, r4, r5
 1231 005e 1B1B     		subs	r3, r3, r4
 1232 0060 02FB03F3 		mul	r3, r2, r3
 1233 0064 B0F90A10 		ldrsh	r1, [r0, #10]
 1234              	.LVL70:
 806:Src/util.c    ****       } else {
 1235              		.loc 1 806 19 view .LVU324
 1236 0068 0C1B     		subs	r4, r1, r4
 1237 006a 93FBF4F3 		sdiv	r3, r3, r4
 806:Src/util.c    ****       } else {
 1238              		.loc 1 806 17 view .LVU325
 1239 006e 9A42     		cmp	r2, r3
 1240 0070 02DB     		blt	.L85
 806:Src/util.c    ****       } else {
 1241              		.loc 1 806 19 discriminator 1 view .LVU326
 1242 0072 23EAE372 		bic	r2, r3, r3, asr #31
 1243              	.LVL71:
 806:Src/util.c    ****       } else {
 1244              		.loc 1 806 17 discriminator 1 view .LVU327
 1245 0076 12B2     		sxth	r2, r2
 1246              	.L85:
 806:Src/util.c    ****       } else {
 1247              		.loc 1 806 17 discriminator 4 view .LVU328
 1248 0078 4280     		strh	r2, [r0, #2]	@ movhi
 1249 007a DCE7     		b	.L77
 1250              	.LVL72:
 1251              	.L84:
 808:Src/util.c    ****       }
 1252              		.loc 1 808 9 is_stmt 1 view .LVU329
 808:Src/util.c    ****       }
 1253              		.loc 1 808 19 is_stmt 0 view .LVU330
 1254 007c 9A1B     		subs	r2, r3, r6
 1255              	.LVL73:
 808:Src/util.c    ****       }
 1256              		.loc 1 808 19 view .LVU331
 1257 007e 01FB02F2 		mul	r2, r1, r2
 1258 0082 B0F90630 		ldrsh	r3, [r0, #6]
 1259 0086 9B1B     		subs	r3, r3, r6
 1260 0088 92FBF3F3 		sdiv	r3, r2, r3
 808:Src/util.c    ****       }
 1261              		.loc 1 808 17 view .LVU332
 1262 008c 002B     		cmp	r3, #0
 1263 008e 02DD     		ble	.L90
 1264 0090 0021     		movs	r1, #0
 1265              	.LVL74:
 1266              	.L86:
 808:Src/util.c    ****       }
 1267              		.loc 1 808 17 discriminator 4 view .LVU333
 1268 0092 4180     		strh	r1, [r0, #2]	@ movhi
 1269 0094 CFE7     		b	.L77
 1270              	.LVL75:
 1271              	.L90:
 808:Src/util.c    ****       }
 1272              		.loc 1 808 19 discriminator 1 view .LVU334
 1273 0096 9942     		cmp	r1, r3
ARM GAS  /tmp/ccNyZSr4.s 			page 40


 1274 0098 B8BF     		it	lt
 1275 009a 1946     		movlt	r1, r3
 1276              	.LVL76:
 808:Src/util.c    ****       }
 1277              		.loc 1 808 17 discriminator 1 view .LVU335
 1278 009c 09B2     		sxth	r1, r1
 1279 009e F8E7     		b	.L86
 1280              		.cfi_endproc
 1281              	.LFE82:
 1283              		.section	.text.readInputRaw,"ax",%progbits
 1284              		.align	1
 1285              		.global	readInputRaw
 1286              		.syntax unified
 1287              		.thumb
 1288              		.thumb_func
 1289              		.fpu softvfp
 1291              	readInputRaw:
 1292              	.LFB83:
 816:Src/util.c    **** 
 817:Src/util.c    ****  /*
 818:Src/util.c    ****  * Function to read the Input Raw values from various input devices
 819:Src/util.c    ****  */
 820:Src/util.c    **** void readInputRaw(void) {
 1293              		.loc 1 820 25 is_stmt 1 view -0
 1294              		.cfi_startproc
 1295              		@ args = 0, pretend = 0, frame = 0
 1296              		@ frame_needed = 0, uses_anonymous_args = 0
 1297              		@ link register save eliminated.
 821:Src/util.c    ****     #ifdef CONTROL_ADC
 822:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1298              		.loc 1 822 5 view .LVU337
 1299              		.loc 1 822 15 is_stmt 0 view .LVU338
 1300 0000 094B     		ldr	r3, .L97
 1301 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1302              		.loc 1 822 8 view .LVU339
 1303 0004 7BB9     		cbnz	r3, .L94
 820:Src/util.c    ****     #ifdef CONTROL_ADC
 1304              		.loc 1 820 25 view .LVU340
 1305 0006 10B4     		push	{r4}
 1306              	.LCFI14:
 1307              		.cfi_def_cfa_offset 4
 1308              		.cfi_offset 4, -4
 823:Src/util.c    ****       input1[inIdx].raw = adc_buffer.l_tx2;
 1309              		.loc 1 823 7 is_stmt 1 view .LVU341
 1310              		.loc 1 823 37 is_stmt 0 view .LVU342
 1311 0008 084A     		ldr	r2, .L97+4
 1312 000a D489     		ldrh	r4, [r2, #14]
 1313              		.loc 1 823 25 view .LVU343
 1314 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1315 0010 4100     		lsls	r1, r0, #1
 1316 0012 0748     		ldr	r0, .L97+8
 1317 0014 4452     		strh	r4, [r0, r1]	@ movhi
 824:Src/util.c    ****       input2[inIdx].raw = adc_buffer.l_rx2;
 1318              		.loc 1 824 7 is_stmt 1 view .LVU344
 1319              		.loc 1 824 37 is_stmt 0 view .LVU345
 1320 0016 518A     		ldrh	r1, [r2, #18]
 1321              		.loc 1 824 25 view .LVU346
ARM GAS  /tmp/ccNyZSr4.s 			page 41


 1322 0018 C3EBC303 		rsb	r3, r3, r3, lsl #3
 1323 001c 5A00     		lsls	r2, r3, #1
 1324 001e 054B     		ldr	r3, .L97+12
 1325 0020 9952     		strh	r1, [r3, r2]	@ movhi
 825:Src/util.c    ****     }
 826:Src/util.c    ****     #endif
 827:Src/util.c    **** 
 828:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 829:Src/util.c    ****     if (nunchuk_connected) {
 830:Src/util.c    ****       Nunchuk_Read();
 831:Src/util.c    ****       if (inIdx == CONTROL_NUNCHUK) {
 832:Src/util.c    ****         input1[inIdx].raw = (nunchuk_data[0] - 127) * 8; // X axis 0-255
 833:Src/util.c    ****         input2[inIdx].raw = (nunchuk_data[1] - 128) * 8; // Y axis 0-255
 834:Src/util.c    ****       }
 835:Src/util.c    ****       #ifdef SUPPORT_BUTTONS
 836:Src/util.c    ****         button1 = (uint8_t)nunchuk_data[5] & 1;
 837:Src/util.c    ****         button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
 838:Src/util.c    ****       #endif
 839:Src/util.c    ****     }
 840:Src/util.c    ****     #endif
 841:Src/util.c    **** 
 842:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2)
 843:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART2) {
 844:Src/util.c    ****       #ifdef CONTROL_IBUS
 845:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 846:Src/util.c    ****           ibusL_captured_value[(i/2)] = CLAMP(commandL.channels[i] + (commandL.channels[i+1] << 8) 
 847:Src/util.c    ****         }
 848:Src/util.c    ****         input1[inIdx].raw = (ibusL_captured_value[0] - 500) * 2;
 849:Src/util.c    ****         input2[inIdx].raw = (ibusL_captured_value[1] - 500) * 2; 
 850:Src/util.c    ****       #else
 851:Src/util.c    ****         input1[inIdx].raw = commandL.steer;
 852:Src/util.c    ****         input2[inIdx].raw = commandL.speed;
 853:Src/util.c    ****       #endif
 854:Src/util.c    ****     }
 855:Src/util.c    ****     #endif
 856:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3)
 857:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART3) {
 858:Src/util.c    ****       #ifdef CONTROL_IBUS
 859:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 860:Src/util.c    ****           ibusR_captured_value[(i/2)] = CLAMP(commandR.channels[i] + (commandR.channels[i+1] << 8) 
 861:Src/util.c    ****         }
 862:Src/util.c    ****         input1[inIdx].raw = (ibusR_captured_value[0] - 500) * 2;
 863:Src/util.c    ****         input2[inIdx].raw = (ibusR_captured_value[1] - 500) * 2; 
 864:Src/util.c    ****       #else
 865:Src/util.c    ****         input1[inIdx].raw = commandR.steer;
 866:Src/util.c    ****         input2[inIdx].raw = commandR.speed;
 867:Src/util.c    ****       #endif
 868:Src/util.c    ****     }
 869:Src/util.c    ****     #endif
 870:Src/util.c    **** 
 871:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 872:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
 873:Src/util.c    ****       input1[inIdx].raw = Sideboard_L.cmd1;
 874:Src/util.c    ****       input2[inIdx].raw = Sideboard_L.cmd2;
 875:Src/util.c    ****     }
 876:Src/util.c    ****     #endif
 877:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
ARM GAS  /tmp/ccNyZSr4.s 			page 42


 878:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
 879:Src/util.c    ****       input1[inIdx].raw = Sideboard_R.cmd1;
 880:Src/util.c    ****       input2[inIdx].raw = Sideboard_R.cmd2;
 881:Src/util.c    ****     }
 882:Src/util.c    ****     #endif
 883:Src/util.c    **** 
 884:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT)
 885:Src/util.c    ****     if (inIdx == CONTROL_PPM_LEFT) {
 886:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 887:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 888:Src/util.c    ****     }
 889:Src/util.c    ****     #endif
 890:Src/util.c    ****     #if defined(CONTROL_PPM_RIGHT)
 891:Src/util.c    ****     if (inIdx == CONTROL_PPM_RIGHT) {
 892:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 893:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 894:Src/util.c    ****     }
 895:Src/util.c    ****     #endif
 896:Src/util.c    ****     #if (defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)) && defined(SUPPORT_BUTTONS)
 897:Src/util.c    ****       button1 = ppm_captured_value[5] > 500;
 898:Src/util.c    ****       button2 = 0;
 899:Src/util.c    ****     #endif
 900:Src/util.c    **** 
 901:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT)
 902:Src/util.c    ****     if (inIdx == CONTROL_PWM_LEFT) {
 903:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 904:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 905:Src/util.c    ****     }
 906:Src/util.c    ****     #endif
 907:Src/util.c    ****     #if defined(CONTROL_PWM_RIGHT)
 908:Src/util.c    ****     if (inIdx == CONTROL_PWM_RIGHT) {
 909:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 910:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 911:Src/util.c    ****     }
 912:Src/util.c    ****     #endif
 913:Src/util.c    **** 
 914:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 915:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 916:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_rx2;
 917:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_tx2;
 918:Src/util.c    ****       #endif
 919:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 920:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_tx2;
 921:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_rx2;
 922:Src/util.c    ****       #endif
 923:Src/util.c    ****     #endif
 924:Src/util.c    **** }
 1326              		.loc 1 924 1 view .LVU347
 1327 0022 10BC     		pop	{r4}
 1328              	.LCFI15:
 1329              		.cfi_restore 4
 1330              		.cfi_def_cfa_offset 0
 1331 0024 7047     		bx	lr
 1332              	.L94:
 1333 0026 7047     		bx	lr
 1334              	.L98:
 1335              		.align	2
ARM GAS  /tmp/ccNyZSr4.s 			page 43


 1336              	.L97:
 1337 0028 00000000 		.word	.LANCHOR5
 1338 002c 00000000 		.word	adc_buffer
 1339 0030 00000000 		.word	.LANCHOR3
 1340 0034 00000000 		.word	.LANCHOR4
 1341              		.cfi_endproc
 1342              	.LFE83:
 1344              		.section	.text.handleTimeout,"ax",%progbits
 1345              		.align	1
 1346              		.global	handleTimeout
 1347              		.syntax unified
 1348              		.thumb
 1349              		.thumb_func
 1350              		.fpu softvfp
 1352              	handleTimeout:
 1353              	.LFB84:
 925:Src/util.c    **** 
 926:Src/util.c    ****  /*
 927:Src/util.c    ****  * Function to handle the ADC, UART and General timeout (Nunchuk, PPM, PWM)
 928:Src/util.c    ****  */
 929:Src/util.c    **** void handleTimeout(void) {
 1354              		.loc 1 929 26 is_stmt 1 view -0
 1355              		.cfi_startproc
 1356              		@ args = 0, pretend = 0, frame = 0
 1357              		@ frame_needed = 0, uses_anonymous_args = 0
 1358              		@ link register save eliminated.
 930:Src/util.c    ****     #ifdef CONTROL_ADC
 931:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1359              		.loc 1 931 5 view .LVU349
 1360              		.loc 1 931 15 is_stmt 0 view .LVU350
 1361 0000 2D4B     		ldr	r3, .L105
 1362 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1363              		.loc 1 931 8 view .LVU351
 1364 0004 002B     		cmp	r3, #0
 1365 0006 3BD1     		bne	.L100
 932:Src/util.c    ****       // If input1 or Input2 is either below MIN - Threshold or above MAX + Threshold, ADC protecti
 933:Src/util.c    ****       if (IN_RANGE(input1[inIdx].raw, input1[inIdx].min - ADC_PROTECT_THRESH, input1[inIdx].max + A
 1366              		.loc 1 933 7 is_stmt 1 view .LVU352
 1367              		.loc 1 933 11 is_stmt 0 view .LVU353
 1368 0008 2C49     		ldr	r1, .L105+4
 1369 000a C3EBC300 		rsb	r0, r3, r3, lsl #3
 1370 000e 4200     		lsls	r2, r0, #1
 1371 0010 8818     		adds	r0, r1, r2
 1372 0012 895E     		ldrsh	r1, [r1, r2]
 1373 0014 B0F90620 		ldrsh	r2, [r0, #6]
 1374 0018 C83A     		subs	r2, r2, #200
 1375              		.loc 1 933 10 view .LVU354
 1376 001a 9142     		cmp	r1, r2
 1377 001c 24DB     		blt	.L101
 1378              		.loc 1 933 11 discriminator 1 view .LVU355
 1379 001e C3EBC302 		rsb	r2, r3, r3, lsl #3
 1380 0022 5000     		lsls	r0, r2, #1
 1381 0024 254A     		ldr	r2, .L105+4
 1382 0026 0244     		add	r2, r2, r0
 1383 0028 B2F90A20 		ldrsh	r2, [r2, #10]
 1384 002c C832     		adds	r2, r2, #200
 1385 002e 9142     		cmp	r1, r2
ARM GAS  /tmp/ccNyZSr4.s 			page 44


 1386 0030 1ADC     		bgt	.L101
 934:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 1387              		.loc 1 934 11 discriminator 2 view .LVU356
 1388 0032 2349     		ldr	r1, .L105+8
 1389 0034 C3EBC300 		rsb	r0, r3, r3, lsl #3
 1390 0038 4200     		lsls	r2, r0, #1
 1391 003a 8818     		adds	r0, r1, r2
 1392 003c 895E     		ldrsh	r1, [r1, r2]
 1393 003e B0F90620 		ldrsh	r2, [r0, #6]
 1394 0042 C83A     		subs	r2, r2, #200
 933:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 1395              		.loc 1 933 119 discriminator 2 view .LVU357
 1396 0044 9142     		cmp	r1, r2
 1397 0046 0FDB     		blt	.L101
 1398              		.loc 1 934 11 view .LVU358
 1399 0048 C3EBC302 		rsb	r2, r3, r3, lsl #3
 1400 004c 5000     		lsls	r0, r2, #1
 1401 004e 1C4A     		ldr	r2, .L105+8
 1402 0050 0244     		add	r2, r2, r0
 1403 0052 B2F90A20 		ldrsh	r2, [r2, #10]
 1404 0056 C832     		adds	r2, r2, #200
 1405 0058 9142     		cmp	r1, r2
 1406 005a 05DC     		bgt	.L101
 935:Src/util.c    ****           timeoutFlgADC = 0;                            // Reset the timeout flag
 1407              		.loc 1 935 11 is_stmt 1 view .LVU359
 1408              		.loc 1 935 25 is_stmt 0 view .LVU360
 1409 005c 0022     		movs	r2, #0
 1410 005e 1949     		ldr	r1, .L105+12
 1411 0060 0A70     		strb	r2, [r1]
 936:Src/util.c    ****           timeoutCntADC = 0;                            // Reset the timeout counter
 1412              		.loc 1 936 11 is_stmt 1 view .LVU361
 1413              		.loc 1 936 25 is_stmt 0 view .LVU362
 1414 0062 1949     		ldr	r1, .L105+16
 1415 0064 0A80     		strh	r2, [r1]	@ movhi
 1416 0066 0BE0     		b	.L100
 1417              	.L101:
 937:Src/util.c    ****       } else {
 938:Src/util.c    ****         if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) {   // Timeout qualification
 1418              		.loc 1 938 9 is_stmt 1 view .LVU363
 1419              		.loc 1 938 26 is_stmt 0 view .LVU364
 1420 0068 1749     		ldr	r1, .L105+16
 1421 006a 0A88     		ldrh	r2, [r1]
 1422 006c 501C     		adds	r0, r2, #1
 1423 006e 0880     		strh	r0, [r1]	@ movhi
 1424              		.loc 1 938 12 view .LVU365
 1425 0070 632A     		cmp	r2, #99
 1426 0072 05D9     		bls	.L100
 939:Src/util.c    ****           timeoutFlgADC = 1;                            // Timeout detected
 1427              		.loc 1 939 11 is_stmt 1 view .LVU366
 1428              		.loc 1 939 25 is_stmt 0 view .LVU367
 1429 0074 134A     		ldr	r2, .L105+12
 1430 0076 0121     		movs	r1, #1
 1431 0078 1170     		strb	r1, [r2]
 940:Src/util.c    ****           timeoutCntADC = ADC_PROTECT_TIMEOUT;          // Limit timout counter value
 1432              		.loc 1 940 11 is_stmt 1 view .LVU368
 1433              		.loc 1 940 25 is_stmt 0 view .LVU369
 1434 007a 134A     		ldr	r2, .L105+16
ARM GAS  /tmp/ccNyZSr4.s 			page 45


 1435 007c 6421     		movs	r1, #100
 1436 007e 1180     		strh	r1, [r2]	@ movhi
 1437              	.L100:
 941:Src/util.c    ****         }
 942:Src/util.c    ****       }
 943:Src/util.c    ****     }
 944:Src/util.c    ****     #endif
 945:Src/util.c    **** 
 946:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 947:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 948:Src/util.c    ****         timeoutFlgSerial_L = 1;                         // Timeout detected
 949:Src/util.c    ****         timeoutCntSerial_L = SERIAL_TIMEOUT;            // Limit timout counter value
 950:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1)
 951:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 952:Src/util.c    ****         #endif
 953:Src/util.c    ****       } else {                                          // No Timeout
 954:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
 955:Src/util.c    ****           if (Sideboard_L.sensors & SW1_SET) {          // If SW1 is set, switch to Sideboard contr
 956:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART2;
 957:Src/util.c    ****           } else {
 958:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART2;
 959:Src/util.c    ****           }
 960:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1
 961:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 962:Src/util.c    ****         #endif
 963:Src/util.c    ****       }
 964:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 0) || (defined(SIDEBOARD_SERI
 965:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_L;          // Report Timeout only on the Primary Input
 966:Src/util.c    ****       #endif
 967:Src/util.c    ****     #endif
 968:Src/util.c    **** 
 969:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 970:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 971:Src/util.c    ****         timeoutFlgSerial_R = 1;                         // Timeout detected
 972:Src/util.c    ****         timeoutCntSerial_R = SERIAL_TIMEOUT;            // Limit timout counter value
 973:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1)
 974:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 975:Src/util.c    ****         #endif
 976:Src/util.c    ****       } else {                                          // No Timeout
 977:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
 978:Src/util.c    ****           if (Sideboard_R.sensors & SW1_SET) {          // If SW1 is set, switch to Sideboard contr
 979:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART3;
 980:Src/util.c    ****           } else {
 981:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART3;
 982:Src/util.c    ****           }
 983:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1
 984:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 985:Src/util.c    ****         #endif
 986:Src/util.c    ****       }
 987:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 0) || (defined(SIDEBOARD_SERI
 988:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_R;          // Report Timeout only on the Primary Input
 989:Src/util.c    ****       #endif
 990:Src/util.c    ****     #endif
 991:Src/util.c    **** 
 992:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
 993:Src/util.c    ****       timeoutFlgSerial = timeoutFlgSerial_L || timeoutFlgSerial_R;
 994:Src/util.c    ****     #endif
ARM GAS  /tmp/ccNyZSr4.s 			page 46


 995:Src/util.c    **** 
 996:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) || \
 997:Src/util.c    ****         defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || def
 998:Src/util.c    ****       if (timeoutCntGen++ >= TIMEOUT) {                 // Timeout qualification
 999:Src/util.c    ****         #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) ||
1000:Src/util.c    ****             (defined(CONTROL_PPM_LEFT) && CONTROL_PPM_LEFT == 0) || (defined(CONTROL_PPM_RIGHT) && 
1001:Src/util.c    ****             (defined(CONTROL_PWM_LEFT) && CONTROL_PWM_LEFT == 0) || (defined(CONTROL_PWM_RIGHT) && 
1002:Src/util.c    ****           timeoutFlgGen = 1;                            // Report Timeout only on the Primary Input
1003:Src/util.c    ****           timeoutCntGen = TIMEOUT;
1004:Src/util.c    ****         #endif
1005:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1006:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1007:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
1008:Src/util.c    ****         #endif
1009:Src/util.c    ****       } else {
1010:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1011:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1012:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1013:Src/util.c    ****         #endif
1014:Src/util.c    ****       }
1015:Src/util.c    ****     #endif
1016:Src/util.c    **** 
1017:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial || timeoutFlgGen) {           // In case of timeout bring
 1438              		.loc 1 1017 5 is_stmt 1 view .LVU370
 1439              		.loc 1 1017 9 is_stmt 0 view .LVU371
 1440 0080 104A     		ldr	r2, .L105+12
 1441 0082 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1442              		.loc 1 1017 8 view .LVU372
 1443 0084 2AB9     		cbnz	r2, .L102
 1444              		.loc 1 1017 23 discriminator 1 view .LVU373
 1445 0086 114A     		ldr	r2, .L105+20
 1446 0088 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1447 008a 12B9     		cbnz	r2, .L102
 1448              		.loc 1 1017 43 discriminator 2 view .LVU374
 1449 008c 104A     		ldr	r2, .L105+24
 1450 008e 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1451 0090 62B1     		cbz	r2, .L103
 1452              	.L102:
1018:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 1453              		.loc 1 1018 7 is_stmt 1 view .LVU375
 1454              		.loc 1 1018 19 is_stmt 0 view .LVU376
 1455 0092 0022     		movs	r2, #0
 1456 0094 0F49     		ldr	r1, .L105+28
 1457 0096 0A70     		strb	r2, [r1]
1019:Src/util.c    ****       input1[inIdx].cmd  = 0;
 1458              		.loc 1 1019 7 is_stmt 1 view .LVU377
 1459              		.loc 1 1019 26 is_stmt 0 view .LVU378
 1460 0098 C3EBC301 		rsb	r1, r3, r3, lsl #3
 1461 009c 4800     		lsls	r0, r1, #1
 1462 009e 0749     		ldr	r1, .L105+4
 1463 00a0 0144     		add	r1, r1, r0
 1464 00a2 4A80     		strh	r2, [r1, #2]	@ movhi
1020:Src/util.c    ****       input2[inIdx].cmd  = 0;
 1465              		.loc 1 1020 7 is_stmt 1 view .LVU379
 1466              		.loc 1 1020 26 is_stmt 0 view .LVU380
 1467 00a4 064B     		ldr	r3, .L105+8
 1468 00a6 0344     		add	r3, r3, r0
ARM GAS  /tmp/ccNyZSr4.s 			page 47


 1469 00a8 5A80     		strh	r2, [r3, #2]	@ movhi
 1470 00aa 7047     		bx	lr
 1471              	.L103:
1021:Src/util.c    ****     } else {
1022:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
 1472              		.loc 1 1022 7 is_stmt 1 view .LVU381
 1473              		.loc 1 1022 19 is_stmt 0 view .LVU382
 1474 00ac 0A4B     		ldr	r3, .L105+32
 1475 00ae 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1476 00b0 084B     		ldr	r3, .L105+28
 1477 00b2 1A70     		strb	r2, [r3]
1023:Src/util.c    ****     }
1024:Src/util.c    **** }
 1478              		.loc 1 1024 1 view .LVU383
 1479 00b4 7047     		bx	lr
 1480              	.L106:
 1481 00b6 00BF     		.align	2
 1482              	.L105:
 1483 00b8 00000000 		.word	.LANCHOR5
 1484 00bc 00000000 		.word	.LANCHOR3
 1485 00c0 00000000 		.word	.LANCHOR4
 1486 00c4 00000000 		.word	.LANCHOR6
 1487 00c8 00000000 		.word	.LANCHOR7
 1488 00cc 00000000 		.word	.LANCHOR8
 1489 00d0 00000000 		.word	timeoutFlgGen
 1490 00d4 00000000 		.word	.LANCHOR9
 1491 00d8 00000000 		.word	.LANCHOR10
 1492              		.cfi_endproc
 1493              	.LFE84:
 1495              		.section	.text.readCommand,"ax",%progbits
 1496              		.align	1
 1497              		.global	readCommand
 1498              		.syntax unified
 1499              		.thumb
 1500              		.thumb_func
 1501              		.fpu softvfp
 1503              	readCommand:
 1504              	.LFB85:
1025:Src/util.c    **** 
1026:Src/util.c    ****  /*
1027:Src/util.c    ****  * Function to calculate the command to the motors. This function also manages:
1028:Src/util.c    ****  * - timeout detection
1029:Src/util.c    ****  * - MIN/MAX limitations and deadband
1030:Src/util.c    ****  */
1031:Src/util.c    **** void readCommand(void) {
 1505              		.loc 1 1031 24 is_stmt 1 view -0
 1506              		.cfi_startproc
 1507              		@ args = 0, pretend = 0, frame = 0
 1508              		@ frame_needed = 0, uses_anonymous_args = 0
 1509 0000 70B5     		push	{r4, r5, r6, lr}
 1510              	.LCFI16:
 1511              		.cfi_def_cfa_offset 16
 1512              		.cfi_offset 4, -16
 1513              		.cfi_offset 5, -12
 1514              		.cfi_offset 6, -8
 1515              		.cfi_offset 14, -4
1032:Src/util.c    ****     readInputRaw();
ARM GAS  /tmp/ccNyZSr4.s 			page 48


 1516              		.loc 1 1032 5 view .LVU385
 1517 0002 FFF7FEFF 		bl	readInputRaw
 1518              	.LVL77:
1033:Src/util.c    **** 
1034:Src/util.c    ****     #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1035:Src/util.c    ****       calcInputCmd(&input1[inIdx], INPUT_MIN, INPUT_MAX);
 1519              		.loc 1 1035 7 view .LVU386
 1520              		.loc 1 1035 27 is_stmt 0 view .LVU387
 1521 0006 0F4E     		ldr	r6, .L109
 1522 0008 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1523              		.loc 1 1035 7 view .LVU388
 1524 000a 0F4D     		ldr	r5, .L109+4
 1525 000c 0F4C     		ldr	r4, .L109+8
 1526 000e C3EBC303 		rsb	r3, r3, r3, lsl #3
 1527 0012 5800     		lsls	r0, r3, #1
 1528 0014 B5F90020 		ldrsh	r2, [r5]
 1529 0018 B4F90010 		ldrsh	r1, [r4]
 1530 001c 0C4B     		ldr	r3, .L109+12
 1531 001e 1844     		add	r0, r0, r3
 1532 0020 FFF7FEFF 		bl	calcInputCmd
 1533              	.LVL78:
1036:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
1037:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_MIN, INPUT_MAX);
 1534              		.loc 1 1037 9 is_stmt 1 view .LVU389
 1535              		.loc 1 1037 29 is_stmt 0 view .LVU390
 1536 0024 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1537              		.loc 1 1037 9 view .LVU391
 1538 0026 C3EBC303 		rsb	r3, r3, r3, lsl #3
 1539 002a 5800     		lsls	r0, r3, #1
 1540 002c B5F90020 		ldrsh	r2, [r5]
 1541 0030 B4F90010 		ldrsh	r1, [r4]
 1542 0034 074B     		ldr	r3, .L109+16
 1543 0036 1844     		add	r0, r0, r3
 1544 0038 FFF7FEFF 		bl	calcInputCmd
 1545              	.LVL79:
1038:Src/util.c    ****       #else
1039:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_BRK, INPUT_MAX);
1040:Src/util.c    ****       #endif
1041:Src/util.c    ****     #endif
1042:Src/util.c    **** 
1043:Src/util.c    ****     handleTimeout();
 1546              		.loc 1 1043 5 is_stmt 1 view .LVU392
 1547 003c FFF7FEFF 		bl	handleTimeout
 1548              	.LVL80:
1044:Src/util.c    **** 
1045:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1046:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 1549              		.loc 1 1046 5 view .LVU393
1047:Src/util.c    ****       brakePressed = (uint8_t)(input1[inIdx].cmd > 50);
1048:Src/util.c    ****     }
1049:Src/util.c    ****     else {
1050:Src/util.c    ****       brakePressed = (uint8_t)(input2[inIdx].cmd < -50);
1051:Src/util.c    ****     }
1052:Src/util.c    ****     #endif
1053:Src/util.c    **** 
1054:Src/util.c    ****     #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
1055:Src/util.c    ****       button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
ARM GAS  /tmp/ccNyZSr4.s 			page 49


1056:Src/util.c    ****       button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
1057:Src/util.c    ****     #endif
1058:Src/util.c    **** 
1059:Src/util.c    ****     #if defined(CRUISE_CONTROL_SUPPORT) && (defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEF
1060:Src/util.c    ****       cruiseControl(button1);                                           // Cruise control activatio
1061:Src/util.c    ****     #endif
1062:Src/util.c    **** }
 1550              		.loc 1 1062 1 is_stmt 0 view .LVU394
 1551 0040 70BD     		pop	{r4, r5, r6, pc}
 1552              	.L110:
 1553 0042 00BF     		.align	2
 1554              	.L109:
 1555 0044 00000000 		.word	.LANCHOR5
 1556 0048 00000000 		.word	.LANCHOR0
 1557 004c 00000000 		.word	.LANCHOR1
 1558 0050 00000000 		.word	.LANCHOR3
 1559 0054 00000000 		.word	.LANCHOR4
 1560              		.cfi_endproc
 1561              	.LFE85:
 1563              		.section	.text.usart2_rx_check,"ax",%progbits
 1564              		.align	1
 1565              		.global	usart2_rx_check
 1566              		.syntax unified
 1567              		.thumb
 1568              		.thumb_func
 1569              		.fpu softvfp
 1571              	usart2_rx_check:
 1572              	.LFB86:
1063:Src/util.c    **** 
1064:Src/util.c    **** 
1065:Src/util.c    **** /*
1066:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
1067:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1068:Src/util.c    ****  */
1069:Src/util.c    **** void usart2_rx_check(void)
1070:Src/util.c    **** {
 1573              		.loc 1 1070 1 is_stmt 1 view -0
 1574              		.cfi_startproc
 1575              		@ args = 0, pretend = 0, frame = 0
 1576              		@ frame_needed = 0, uses_anonymous_args = 0
 1577              		@ link register save eliminated.
1071:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1072:Src/util.c    ****   static uint32_t old_pos;
1073:Src/util.c    ****   uint32_t pos;
1074:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
1075:Src/util.c    ****   #endif
1076:Src/util.c    **** 
1077:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
1078:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1079:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1080:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
1081:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1082:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], rx_buffer_L_len - old_pos); // First Process data 
1083:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1084:Src/util.c    ****         usart_process_debug(&rx_buffer_L[0], pos);                      // Process remaining data
1085:Src/util.c    ****       }
1086:Src/util.c    ****     }
ARM GAS  /tmp/ccNyZSr4.s 			page 50


1087:Src/util.c    ****   }
1088:Src/util.c    ****   #endif // DEBUG_SERIAL_USART2
1089:Src/util.c    **** 
1090:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
1091:Src/util.c    ****   uint8_t *ptr;	
1092:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1093:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
1094:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
1095:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
1096:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1097:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
1098:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1099:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1100:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1101:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1102:Src/util.c    ****       }
1103:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1104:Src/util.c    ****     }
1105:Src/util.c    ****   }
1106:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
1107:Src/util.c    **** 
1108:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART2
1109:Src/util.c    ****   uint8_t *ptr;	
1110:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1111:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
1112:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
1113:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
1114:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1115:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
1116:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1117:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1118:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1119:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1120:Src/util.c    ****       }
1121:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1122:Src/util.c    ****     }
1123:Src/util.c    ****   }
1124:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
1125:Src/util.c    **** 
1126:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1127:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1128:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
1129:Src/util.c    ****     old_pos = 0;
1130:Src/util.c    ****   }
1131:Src/util.c    **** 	#endif
1132:Src/util.c    **** }
 1578              		.loc 1 1132 1 view .LVU396
 1579 0000 7047     		bx	lr
 1580              		.cfi_endproc
 1581              	.LFE86:
 1583              		.section	.text.usart3_rx_check,"ax",%progbits
 1584              		.align	1
 1585              		.global	usart3_rx_check
 1586              		.syntax unified
 1587              		.thumb
 1588              		.thumb_func
 1589              		.fpu softvfp
ARM GAS  /tmp/ccNyZSr4.s 			page 51


 1591              	usart3_rx_check:
 1592              	.LFB87:
1133:Src/util.c    **** 
1134:Src/util.c    **** 
1135:Src/util.c    **** /*
1136:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
1137:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1138:Src/util.c    ****  */
1139:Src/util.c    **** void usart3_rx_check(void)
1140:Src/util.c    **** {
 1593              		.loc 1 1140 1 view -0
 1594              		.cfi_startproc
 1595              		@ args = 0, pretend = 0, frame = 0
 1596              		@ frame_needed = 0, uses_anonymous_args = 0
 1597              		@ link register save eliminated.
1141:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1142:Src/util.c    ****   static uint32_t old_pos;
1143:Src/util.c    ****   uint32_t pos;  
1144:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
1145:Src/util.c    ****   #endif
1146:Src/util.c    **** 
1147:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
1148:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1149:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1150:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
1151:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1152:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], rx_buffer_R_len - old_pos); // First Process data 
1153:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1154:Src/util.c    ****         usart_process_debug(&rx_buffer_R[0], pos);                      // Process remaining data
1155:Src/util.c    ****       }
1156:Src/util.c    ****     }
1157:Src/util.c    ****   }
1158:Src/util.c    ****   #endif // DEBUG_SERIAL_USART3
1159:Src/util.c    **** 
1160:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
1161:Src/util.c    ****   uint8_t *ptr;	
1162:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1163:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
1164:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
1165:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
1166:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1167:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
1168:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1169:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1170:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1171:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1172:Src/util.c    ****       }
1173:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1174:Src/util.c    ****     }
1175:Src/util.c    ****   }
1176:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
1177:Src/util.c    **** 
1178:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART3
1179:Src/util.c    ****   uint8_t *ptr;
1180:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1181:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
1182:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
ARM GAS  /tmp/ccNyZSr4.s 			page 52


1183:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
1184:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1185:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
1186:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1187:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1188:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1189:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1190:Src/util.c    ****       }
1191:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1192:Src/util.c    ****     }
1193:Src/util.c    ****   }
1194:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1195:Src/util.c    **** 
1196:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1197:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1198:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
1199:Src/util.c    ****     old_pos = 0;
1200:Src/util.c    ****   }
1201:Src/util.c    ****   #endif
1202:Src/util.c    **** }
 1598              		.loc 1 1202 1 view .LVU398
 1599 0000 7047     		bx	lr
 1600              		.cfi_endproc
 1601              	.LFE87:
 1603              		.section	.text.sideboardLeds,"ax",%progbits
 1604              		.align	1
 1605              		.global	sideboardLeds
 1606              		.syntax unified
 1607              		.thumb
 1608              		.thumb_func
 1609              		.fpu softvfp
 1611              	sideboardLeds:
 1612              	.LVL81:
 1613              	.LFB88:
1203:Src/util.c    **** 
1204:Src/util.c    **** /*
1205:Src/util.c    ****  * Process Rx debug user command input
1206:Src/util.c    ****  */
1207:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1208:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
1209:Src/util.c    **** {
1210:Src/util.c    ****   for (; len > 0; len--, userCommand++) {
1211:Src/util.c    ****     if (*userCommand != '\n' && *userCommand != '\r') {   // Do not accept 'new line' and 'carriage
1212:Src/util.c    ****       printf("Command = %c\r\n", *userCommand);
1213:Src/util.c    ****       // handle_input(*userCommand);                      // -> Create this function to handle the 
1214:Src/util.c    ****     }
1215:Src/util.c    ****   }
1216:Src/util.c    **** }
1217:Src/util.c    **** #endif // SERIAL_DEBUG
1218:Src/util.c    **** 
1219:Src/util.c    **** /*
1220:Src/util.c    ****  * Process command Rx data
1221:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1222:Src/util.c    ****  */
1223:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1224:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1225:Src/util.c    **** {
ARM GAS  /tmp/ccNyZSr4.s 			page 53


1226:Src/util.c    ****   #ifdef CONTROL_IBUS
1227:Src/util.c    ****     uint16_t ibus_chksum;
1228:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1229:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1230:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1231:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1232:Src/util.c    ****       }
1233:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1234:Src/util.c    ****         *command_out = *command_in;
1235:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1236:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
1237:Src/util.c    ****           timeoutFlgSerial_L = 0;         // Clear timeout flag
1238:Src/util.c    ****           timeoutCntSerial_L = 0;         // Reset timeout counter
1239:Src/util.c    ****           #endif
1240:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1241:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1242:Src/util.c    ****           timeoutFlgSerial_R = 0;         // Clear timeout flag
1243:Src/util.c    ****           timeoutCntSerial_R = 0;         // Reset timeout counter
1244:Src/util.c    ****           #endif
1245:Src/util.c    ****         }
1246:Src/util.c    ****       }
1247:Src/util.c    ****     }
1248:Src/util.c    ****   #else
1249:Src/util.c    ****   uint16_t checksum;
1250:Src/util.c    ****   if (command_in->start == SERIAL_START_FRAME) {
1251:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
1252:Src/util.c    ****     if (command_in->checksum == checksum) {
1253:Src/util.c    ****       *command_out = *command_in;
1254:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1255:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1256:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1257:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
1258:Src/util.c    ****         #endif
1259:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1260:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1261:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1262:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1263:Src/util.c    ****         #endif
1264:Src/util.c    ****       }
1265:Src/util.c    ****     }
1266:Src/util.c    ****   }
1267:Src/util.c    ****   #endif
1268:Src/util.c    **** }
1269:Src/util.c    **** #endif
1270:Src/util.c    **** 
1271:Src/util.c    **** /*
1272:Src/util.c    ****  * Process Sideboard Rx data
1273:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1274:Src/util.c    ****  */
1275:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1276:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1277:Src/util.c    **** {
1278:Src/util.c    ****   uint16_t checksum;
1279:Src/util.c    ****   if (Sideboard_in->start == SERIAL_START_FRAME) {
1280:Src/util.c    ****     checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->pitch ^ Sideboard_in->dPitch ^ Sidebo
1281:Src/util.c    ****     if (Sideboard_in->checksum == checksum) {
1282:Src/util.c    ****       *Sideboard_out = *Sideboard_in;
ARM GAS  /tmp/ccNyZSr4.s 			page 54


1283:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1284:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
1285:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1286:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1287:Src/util.c    ****         #endif
1288:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1289:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1290:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1291:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1292:Src/util.c    ****         #endif
1293:Src/util.c    ****       }
1294:Src/util.c    ****     }
1295:Src/util.c    ****   }
1296:Src/util.c    **** }
1297:Src/util.c    **** #endif
1298:Src/util.c    **** 
1299:Src/util.c    **** 
1300:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1301:Src/util.c    **** 
1302:Src/util.c    **** /*
1303:Src/util.c    ****  * Sideboard LEDs Handling
1304:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1305:Src/util.c    ****  */
1306:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1614              		.loc 1 1306 35 view -0
 1615              		.cfi_startproc
 1616              		@ args = 0, pretend = 0, frame = 0
 1617              		@ frame_needed = 0, uses_anonymous_args = 0
 1618              		@ link register save eliminated.
1307:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1308:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1309:Src/util.c    ****     // enable == 1, turn on led
1310:Src/util.c    ****     // enable == 0, blink led
1311:Src/util.c    ****     if (enable) {
1312:Src/util.c    ****       *leds |= LED4_SET;
1313:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
1314:Src/util.c    ****       *leds ^= LED4_SET;
1315:Src/util.c    ****     }
1316:Src/util.c    **** 
1317:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1318:Src/util.c    ****     // backwardDrive == 1, blink led
1319:Src/util.c    ****     // backwardDrive == 0, turn off led
1320:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1321:Src/util.c    ****       *leds ^= LED5_SET;
1322:Src/util.c    ****     }
1323:Src/util.c    **** 
1324:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1325:Src/util.c    ****     // brakePressed == 1, turn on led
1326:Src/util.c    ****     // brakePressed == 0, turn off led
1327:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1328:Src/util.c    ****       if (brakePressed) {
1329:Src/util.c    ****         *leds |= LED5_SET;
1330:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1331:Src/util.c    ****         *leds &= ~LED5_SET;
1332:Src/util.c    ****       }
1333:Src/util.c    ****     #endif
1334:Src/util.c    **** 
ARM GAS  /tmp/ccNyZSr4.s 			page 55


1335:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1336:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
1337:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1338:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;
1339:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1340:Src/util.c    ****         *leds ^= LED1_SET;
1341:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1342:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1343:Src/util.c    ****         *leds |= LED1_SET;
1344:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1345:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1346:Src/util.c    ****         *leds ^= LED3_SET;
1347:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1348:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1349:Src/util.c    ****         *leds |= LED3_SET;
1350:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1351:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1352:Src/util.c    ****         *leds ^= LED2_SET;
1353:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1354:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1355:Src/util.c    ****         *leds |= LED2_SET;
1356:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1357:Src/util.c    ****       }
1358:Src/util.c    ****     }
1359:Src/util.c    **** 
1360:Src/util.c    ****     // Error handling
1361:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1362:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1363:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1364:Src/util.c    ****       *leds |= LED1_SET;
1365:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1366:Src/util.c    ****     }
1367:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial) {
1368:Src/util.c    ****       *leds |= LED3_SET;
1369:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1370:Src/util.c    ****     }
1371:Src/util.c    ****   #endif
1372:Src/util.c    **** }
 1619              		.loc 1 1372 1 view .LVU400
 1620 0000 7047     		bx	lr
 1621              		.cfi_endproc
 1622              	.LFE88:
 1624              		.section	.text.sideboardSensors,"ax",%progbits
 1625              		.align	1
 1626              		.global	sideboardSensors
 1627              		.syntax unified
 1628              		.thumb
 1629              		.thumb_func
 1630              		.fpu softvfp
 1632              	sideboardSensors:
 1633              	.LVL82:
 1634              	.LFB89:
1373:Src/util.c    **** 
1374:Src/util.c    **** /*
1375:Src/util.c    ****  * Sideboard Sensor Handling
1376:Src/util.c    ****  * This function manages the sideboards photo sensors.
1377:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
ARM GAS  /tmp/ccNyZSr4.s 			page 56


1378:Src/util.c    ****  */
1379:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1635              		.loc 1 1379 40 view -0
 1636              		.cfi_startproc
 1637              		@ args = 0, pretend = 0, frame = 0
 1638              		@ frame_needed = 0, uses_anonymous_args = 0
 1639              		@ link register save eliminated.
1380:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1381:Src/util.c    ****     static uint8_t sensor1_prev, sensor2_prev;
1382:Src/util.c    ****     static uint8_t sensor1_index;                                 // holds the press index number f
1383:Src/util.c    ****     uint8_t sensor1_trig, sensor2_trig;
1384:Src/util.c    ****     sensor1_trig  = (sensors & SENSOR1_SET) && !sensor1_prev;     // rising edge detection
1385:Src/util.c    ****     sensor2_trig  = (sensors & SENSOR2_SET) && !sensor2_prev;     // rising edge detection
1386:Src/util.c    ****     sensor1_prev  =  sensors & SENSOR1_SET;
1387:Src/util.c    ****     sensor2_prev  =  sensors & SENSOR2_SET;
1388:Src/util.c    **** 
1389:Src/util.c    ****     // Override in case the Sideboard control is Active
1390:Src/util.c    ****     #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
1391:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
1392:Src/util.c    ****       sensor1_index = 3 + ((Sideboard_L.sensors & SW2_SET) >> 9); // SW2 on RC transmitter is used 
1393:Src/util.c    ****       if (sensor1_index == 3) {                                   // FOC control Type
1394:Src/util.c    ****         sensor1_index = (Sideboard_L.sensors & SW3_SET) >> 11;    // SW3 on RC transmitter is used 
1395:Src/util.c    ****       }
1396:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1397:Src/util.c    ****       sensor1_prev  = sensor1_index;
1398:Src/util.c    ****     }
1399:Src/util.c    ****     #endif
1400:Src/util.c    ****     #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
1401:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
1402:Src/util.c    ****       sensor1_index = 3 + ((Sideboard_R.sensors & SW2_SET) >> 9); // SW2 on RC transmitter is used 
1403:Src/util.c    ****       if (sensor1_index == 3) {                                   // FOC control Type
1404:Src/util.c    ****         sensor1_index = (Sideboard_R.sensors & SW3_SET) >> 11;    // SW3 on RC transmitter is used 
1405:Src/util.c    ****       }
1406:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1407:Src/util.c    ****       sensor1_prev  = sensor1_index;
1408:Src/util.c    ****     }
1409:Src/util.c    ****     #endif
1410:Src/util.c    **** 
1411:Src/util.c    ****     // Control MODE and Control Type Handling
1412:Src/util.c    ****     if (sensor1_trig) {
1413:Src/util.c    ****       switch (sensor1_index) {
1414:Src/util.c    ****         case 0:     // FOC VOLTAGE
1415:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1416:Src/util.c    ****           ctrlModReqRaw         = VLT_MODE;
1417:Src/util.c    ****           break;
1418:Src/util.c    ****         case 1:     // FOC SPEED
1419:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1420:Src/util.c    ****           ctrlModReqRaw         = SPD_MODE;
1421:Src/util.c    ****           break;
1422:Src/util.c    ****         case 2:     // FOC TORQUE
1423:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1424:Src/util.c    ****           ctrlModReqRaw         = TRQ_MODE;
1425:Src/util.c    ****           break;
1426:Src/util.c    ****         case 3:     // SINUSOIDAL
1427:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = SIN_CTRL;
1428:Src/util.c    ****           break;
1429:Src/util.c    ****         case 4:     // COMMUTATION
ARM GAS  /tmp/ccNyZSr4.s 			page 57


1430:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = COM_CTRL;
1431:Src/util.c    ****           break;
1432:Src/util.c    ****       }
1433:Src/util.c    ****       beepShortMany(sensor1_index + 1, 1);
1434:Src/util.c    ****       if (++sensor1_index > 4) { sensor1_index = 0; }
1435:Src/util.c    ****     }
1436:Src/util.c    **** 
1437:Src/util.c    ****     // Field Weakening Activation/Deactivation
1438:Src/util.c    ****     #ifdef CRUISE_CONTROL_SUPPORT
1439:Src/util.c    ****       if (sensor2_trig) {
1440:Src/util.c    ****         cruiseControl(sensor2_trig);
1441:Src/util.c    ****       }
1442:Src/util.c    ****     #else
1443:Src/util.c    ****       static uint8_t  sensor2_index = 1;                          // holds the press index number f
1444:Src/util.c    **** 
1445:Src/util.c    ****       // Override in case the Sideboard control is Active
1446:Src/util.c    ****       #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
1447:Src/util.c    ****       if (inIdx == SIDEBOARD_SERIAL_USART2) {
1448:Src/util.c    ****         sensor2_index = (Sideboard_L.sensors & SW4_SET) >> 13;    // SW4 on RC transmitter is used 
1449:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1450:Src/util.c    ****         sensor2_prev  = sensor2_index;
1451:Src/util.c    ****       }
1452:Src/util.c    ****       #endif
1453:Src/util.c    ****       #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
1454:Src/util.c    ****       if (inIdx == SIDEBOARD_SERIAL_USART3) {
1455:Src/util.c    ****         sensor2_index = (Sideboard_R.sensors & SW4_SET) >> 13;    // SW4 on RC transmitter is used 
1456:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1457:Src/util.c    ****         sensor2_prev  = sensor2_index;
1458:Src/util.c    ****       }
1459:Src/util.c    ****       #endif
1460:Src/util.c    **** 
1461:Src/util.c    ****       if (sensor2_trig) {
1462:Src/util.c    ****         switch (sensor2_index) {
1463:Src/util.c    ****           case 0:     // FW Disabled
1464:Src/util.c    ****             rtP_Left.b_fieldWeakEna  = 0; 
1465:Src/util.c    ****             rtP_Right.b_fieldWeakEna = 0;
1466:Src/util.c    ****             Input_Lim_Init();
1467:Src/util.c    ****             break;
1468:Src/util.c    ****           case 1:     // FW Enabled
1469:Src/util.c    ****             rtP_Left.b_fieldWeakEna  = 1; 
1470:Src/util.c    ****             rtP_Right.b_fieldWeakEna = 1;
1471:Src/util.c    ****             Input_Lim_Init();
1472:Src/util.c    ****             break; 
1473:Src/util.c    ****         }
1474:Src/util.c    ****         beepShortMany(sensor2_index + 1, 1);
1475:Src/util.c    ****         if (++sensor2_index > 1) { sensor2_index = 0; }
1476:Src/util.c    ****       }
1477:Src/util.c    ****     #endif  // CRUISE_CONTROL_SUPPORT
1478:Src/util.c    ****   #endif
1479:Src/util.c    **** }
 1640              		.loc 1 1479 1 view .LVU402
 1641 0000 7047     		bx	lr
 1642              		.cfi_endproc
 1643              	.LFE89:
 1645              		.section	.text.saveConfig,"ax",%progbits
 1646              		.align	1
 1647              		.global	saveConfig
ARM GAS  /tmp/ccNyZSr4.s 			page 58


 1648              		.syntax unified
 1649              		.thumb
 1650              		.thumb_func
 1651              		.fpu softvfp
 1653              	saveConfig:
 1654              	.LFB90:
1480:Src/util.c    **** 
1481:Src/util.c    **** 
1482:Src/util.c    **** 
1483:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
1484:Src/util.c    **** 
1485:Src/util.c    ****  /*
1486:Src/util.c    ****  * Save Configuration to Flash
1487:Src/util.c    ****  * This function makes sure data is not lost after power-off
1488:Src/util.c    ****  */
1489:Src/util.c    **** void saveConfig() {
 1655              		.loc 1 1489 19 view -0
 1656              		.cfi_startproc
 1657              		@ args = 0, pretend = 0, frame = 0
 1658              		@ frame_needed = 0, uses_anonymous_args = 0
 1659 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1660              	.LCFI17:
 1661              		.cfi_def_cfa_offset 32
 1662              		.cfi_offset 3, -32
 1663              		.cfi_offset 4, -28
 1664              		.cfi_offset 5, -24
 1665              		.cfi_offset 6, -20
 1666              		.cfi_offset 7, -16
 1667              		.cfi_offset 8, -12
 1668              		.cfi_offset 9, -8
 1669              		.cfi_offset 14, -4
1490:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
1491:Src/util.c    ****     if (saveValue_valid) {
1492:Src/util.c    ****       HAL_FLASH_Unlock();
1493:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
1494:Src/util.c    ****       HAL_FLASH_Lock();
1495:Src/util.c    ****     }
1496:Src/util.c    ****   #endif
1497:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1498:Src/util.c    ****     if (inp_cal_valid || cur_spd_valid) {
 1670              		.loc 1 1498 5 view .LVU404
 1671              		.loc 1 1498 9 is_stmt 0 view .LVU405
 1672 0004 374B     		ldr	r3, .L121
 1673 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1674              		.loc 1 1498 8 view .LVU406
 1675 0008 13B9     		cbnz	r3, .L116
 1676              		.loc 1 1498 23 discriminator 1 view .LVU407
 1677 000a 374B     		ldr	r3, .L121+4
 1678 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1679 000e C3B1     		cbz	r3, .L115
 1680              	.L116:
1499:Src/util.c    ****       HAL_FLASH_Unlock();
 1681              		.loc 1 1499 7 is_stmt 1 view .LVU408
 1682 0010 FFF7FEFF 		bl	HAL_FLASH_Unlock
 1683              	.LVL83:
1500:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0] , (uint16_t)FLASH_WRITE_KEY);
 1684              		.loc 1 1500 7 view .LVU409
ARM GAS  /tmp/ccNyZSr4.s 			page 59


 1685 0014 354C     		ldr	r4, .L121+8
 1686 0016 41F20711 		movw	r1, #4359
 1687 001a 2088     		ldrh	r0, [r4]
 1688 001c FFF7FEFF 		bl	EE_WriteVariable
 1689              	.LVL84:
1501:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1] , (uint16_t)rtP_Left.i_max);
 1690              		.loc 1 1501 7 view .LVU410
 1691              		.loc 1 1501 61 is_stmt 0 view .LVU411
 1692 0020 334D     		ldr	r5, .L121+12
 1693 0022 B5F9CE10 		ldrsh	r1, [r5, #206]
 1694              		.loc 1 1501 7 view .LVU412
 1695 0026 89B2     		uxth	r1, r1
 1696 0028 6088     		ldrh	r0, [r4, #2]
 1697 002a FFF7FEFF 		bl	EE_WriteVariable
 1698              	.LVL85:
1502:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2] , (uint16_t)rtP_Left.n_max);
 1699              		.loc 1 1502 7 is_stmt 1 view .LVU413
 1700              		.loc 1 1502 61 is_stmt 0 view .LVU414
 1701 002e B5F9DA10 		ldrsh	r1, [r5, #218]
 1702              		.loc 1 1502 7 view .LVU415
 1703 0032 89B2     		uxth	r1, r1
 1704 0034 A088     		ldrh	r0, [r4, #4]
 1705 0036 FFF7FEFF 		bl	EE_WriteVariable
 1706              	.LVL86:
1503:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 1707              		.loc 1 1503 7 is_stmt 1 view .LVU416
 1708              	.LBB8:
 1709              		.loc 1 1503 12 view .LVU417
 1710              		.loc 1 1503 20 is_stmt 0 view .LVU418
 1711 003a 0025     		movs	r5, #0
 1712              	.LVL87:
 1713              	.L118:
 1714              		.loc 1 1503 25 is_stmt 1 discriminator 1 view .LVU419
 1715              		.loc 1 1503 7 is_stmt 0 discriminator 1 view .LVU420
 1716 003c 1DB1     		cbz	r5, .L119
 1717              	.LBE8:
1504:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
1505:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 4+8*i] , (uint16_t)input1[i].min);
1506:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
1507:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
1508:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
1509:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
1510:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
1511:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
1512:Src/util.c    ****       }
1513:Src/util.c    ****       HAL_FLASH_Lock();
 1718              		.loc 1 1513 7 is_stmt 1 view .LVU421
 1719 003e FFF7FEFF 		bl	HAL_FLASH_Lock
 1720              	.LVL88:
 1721              	.L115:
1514:Src/util.c    ****     }
1515:Src/util.c    ****   #endif 
1516:Src/util.c    **** }
 1722              		.loc 1 1516 1 is_stmt 0 view .LVU422
 1723 0042 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1724              	.LVL89:
 1725              	.L119:
ARM GAS  /tmp/ccNyZSr4.s 			page 60


 1726              	.LBB9:
1504:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1727              		.loc 1 1504 9 is_stmt 1 discriminator 3 view .LVU423
1504:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1728              		.loc 1 1504 44 is_stmt 0 discriminator 3 view .LVU424
 1729 0046 EC00     		lsls	r4, r5, #3
1504:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1730              		.loc 1 1504 42 discriminator 3 view .LVU425
 1731 0048 E01C     		adds	r0, r4, #3
1504:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1732              		.loc 1 1504 69 discriminator 3 view .LVU426
 1733 004a 621B     		subs	r2, r4, r5
 1734 004c 5300     		lsls	r3, r2, #1
 1735 004e 294F     		ldr	r7, .L121+16
 1736 0050 1F44     		add	r7, r7, r3
1504:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1737              		.loc 1 1504 9 discriminator 3 view .LVU427
 1738 0052 264E     		ldr	r6, .L121+8
 1739 0054 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1740 0056 36F81000 		ldrh	r0, [r6, r0, lsl #1]
 1741 005a FFF7FEFF 		bl	EE_WriteVariable
 1742              	.LVL90:
1505:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1743              		.loc 1 1505 9 is_stmt 1 discriminator 3 view .LVU428
1505:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1744              		.loc 1 1505 42 is_stmt 0 discriminator 3 view .LVU429
 1745 005e 231D     		adds	r3, r4, #4
1505:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1746              		.loc 1 1505 69 discriminator 3 view .LVU430
 1747 0060 B7F90610 		ldrsh	r1, [r7, #6]
1505:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1748              		.loc 1 1505 9 discriminator 3 view .LVU431
 1749 0064 89B2     		uxth	r1, r1
 1750 0066 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1751 006a FFF7FEFF 		bl	EE_WriteVariable
 1752              	.LVL91:
1506:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1753              		.loc 1 1506 9 is_stmt 1 discriminator 3 view .LVU432
1506:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1754              		.loc 1 1506 42 is_stmt 0 discriminator 3 view .LVU433
 1755 006e 631D     		adds	r3, r4, #5
1506:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1756              		.loc 1 1506 69 discriminator 3 view .LVU434
 1757 0070 B7F90810 		ldrsh	r1, [r7, #8]
1506:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1758              		.loc 1 1506 9 discriminator 3 view .LVU435
 1759 0074 89B2     		uxth	r1, r1
 1760 0076 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1761 007a FFF7FEFF 		bl	EE_WriteVariable
 1762              	.LVL92:
1507:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1763              		.loc 1 1507 9 is_stmt 1 discriminator 3 view .LVU436
1507:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1764              		.loc 1 1507 42 is_stmt 0 discriminator 3 view .LVU437
 1765 007e A31D     		adds	r3, r4, #6
1507:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1766              		.loc 1 1507 69 discriminator 3 view .LVU438
ARM GAS  /tmp/ccNyZSr4.s 			page 61


 1767 0080 B7F90A10 		ldrsh	r1, [r7, #10]
1507:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1768              		.loc 1 1507 9 discriminator 3 view .LVU439
 1769 0084 89B2     		uxth	r1, r1
 1770 0086 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1771 008a FFF7FEFF 		bl	EE_WriteVariable
 1772              	.LVL93:
1508:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1773              		.loc 1 1508 9 is_stmt 1 discriminator 3 view .LVU440
1508:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1774              		.loc 1 1508 42 is_stmt 0 discriminator 3 view .LVU441
 1775 008e E21D     		adds	r2, r4, #7
1508:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1776              		.loc 1 1508 69 discriminator 3 view .LVU442
 1777 0090 DFF86480 		ldr	r8, .L121+20
 1778 0094 631B     		subs	r3, r4, r5
 1779 0096 5F00     		lsls	r7, r3, #1
 1780 0098 4744     		add	r7, r7, r8
1508:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1781              		.loc 1 1508 9 discriminator 3 view .LVU443
 1782 009a 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1783 009c 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1784 00a0 FFF7FEFF 		bl	EE_WriteVariable
 1785              	.LVL94:
1509:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1786              		.loc 1 1509 9 is_stmt 1 discriminator 3 view .LVU444
1509:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1787              		.loc 1 1509 42 is_stmt 0 discriminator 3 view .LVU445
 1788 00a4 05F10109 		add	r9, r5, #1
 1789 00a8 4FEAC903 		lsl	r3, r9, #3
1509:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1790              		.loc 1 1509 69 discriminator 3 view .LVU446
 1791 00ac B7F90610 		ldrsh	r1, [r7, #6]
1509:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1792              		.loc 1 1509 9 discriminator 3 view .LVU447
 1793 00b0 89B2     		uxth	r1, r1
 1794 00b2 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1795 00b6 FFF7FEFF 		bl	EE_WriteVariable
 1796              	.LVL95:
1510:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1797              		.loc 1 1510 9 is_stmt 1 discriminator 3 view .LVU448
1510:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1798              		.loc 1 1510 42 is_stmt 0 discriminator 3 view .LVU449
 1799 00ba 04F10903 		add	r3, r4, #9
1510:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1800              		.loc 1 1510 69 discriminator 3 view .LVU450
 1801 00be B7F90810 		ldrsh	r1, [r7, #8]
1510:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1802              		.loc 1 1510 9 discriminator 3 view .LVU451
 1803 00c2 89B2     		uxth	r1, r1
 1804 00c4 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1805 00c8 FFF7FEFF 		bl	EE_WriteVariable
 1806              	.LVL96:
1511:Src/util.c    ****       }
 1807              		.loc 1 1511 9 is_stmt 1 discriminator 3 view .LVU452
1511:Src/util.c    ****       }
 1808              		.loc 1 1511 42 is_stmt 0 discriminator 3 view .LVU453
ARM GAS  /tmp/ccNyZSr4.s 			page 62


 1809 00cc 04F10A02 		add	r2, r4, #10
1511:Src/util.c    ****       }
 1810              		.loc 1 1511 69 discriminator 3 view .LVU454
 1811 00d0 B7F90A10 		ldrsh	r1, [r7, #10]
1511:Src/util.c    ****       }
 1812              		.loc 1 1511 9 discriminator 3 view .LVU455
 1813 00d4 89B2     		uxth	r1, r1
 1814 00d6 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1815 00da FFF7FEFF 		bl	EE_WriteVariable
 1816              	.LVL97:
1503:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1817              		.loc 1 1503 38 is_stmt 1 discriminator 3 view .LVU456
1503:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1818              		.loc 1 1503 39 is_stmt 0 discriminator 3 view .LVU457
 1819 00de 5FFA89F5 		uxtb	r5, r9
 1820              	.LVL98:
1503:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1821              		.loc 1 1503 39 discriminator 3 view .LVU458
 1822 00e2 ABE7     		b	.L118
 1823              	.L122:
 1824              		.align	2
 1825              	.L121:
 1826 00e4 00000000 		.word	.LANCHOR11
 1827 00e8 00000000 		.word	.LANCHOR12
 1828 00ec 00000000 		.word	.LANCHOR2
 1829 00f0 00000000 		.word	rtP_Left
 1830 00f4 00000000 		.word	.LANCHOR3
 1831 00f8 00000000 		.word	.LANCHOR4
 1832              	.LBE9:
 1833              		.cfi_endproc
 1834              	.LFE90:
 1836              		.section	.text.poweroff,"ax",%progbits
 1837              		.align	1
 1838              		.global	poweroff
 1839              		.syntax unified
 1840              		.thumb
 1841              		.thumb_func
 1842              		.fpu softvfp
 1844              	poweroff:
 1845              	.LFB91:
1517:Src/util.c    **** 
1518:Src/util.c    **** 
1519:Src/util.c    **** void poweroff(void) {
 1846              		.loc 1 1519 21 is_stmt 1 view -0
 1847              		.cfi_startproc
 1848              		@ args = 0, pretend = 0, frame = 0
 1849              		@ frame_needed = 0, uses_anonymous_args = 0
 1850 0000 10B5     		push	{r4, lr}
 1851              	.LCFI18:
 1852              		.cfi_def_cfa_offset 8
 1853              		.cfi_offset 4, -8
 1854              		.cfi_offset 14, -4
1520:Src/util.c    ****   enable = 0;
 1855              		.loc 1 1520 3 view .LVU460
 1856              		.loc 1 1520 10 is_stmt 0 view .LVU461
 1857 0002 0024     		movs	r4, #0
 1858 0004 0B4B     		ldr	r3, .L128
ARM GAS  /tmp/ccNyZSr4.s 			page 63


 1859 0006 1C70     		strb	r4, [r3]
1521:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1522:Src/util.c    ****   printf("-- Motors disabled --\r\n");
1523:Src/util.c    ****   #endif
1524:Src/util.c    ****   buzzerCount = 0;  // prevent interraction with beep counter
 1860              		.loc 1 1524 3 is_stmt 1 view .LVU462
 1861              		.loc 1 1524 15 is_stmt 0 view .LVU463
 1862 0008 0B4B     		ldr	r3, .L128+4
 1863 000a 1C70     		strb	r4, [r3]
1525:Src/util.c    ****   buzzerPattern = 0;
 1864              		.loc 1 1525 3 is_stmt 1 view .LVU464
 1865              		.loc 1 1525 17 is_stmt 0 view .LVU465
 1866 000c 0B4B     		ldr	r3, .L128+8
 1867 000e 1C70     		strb	r4, [r3]
1526:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1868              		.loc 1 1526 3 is_stmt 1 view .LVU466
 1869              	.LBB10:
 1870              		.loc 1 1526 8 view .LVU467
 1871              	.LVL99:
 1872              		.loc 1 1526 3 is_stmt 0 view .LVU468
 1873 0010 05E0     		b	.L124
 1874              	.LVL100:
 1875              	.L125:
1527:Src/util.c    ****     buzzerFreq = (uint8_t)i;
 1876              		.loc 1 1527 5 is_stmt 1 discriminator 3 view .LVU469
 1877              		.loc 1 1527 16 is_stmt 0 discriminator 3 view .LVU470
 1878 0012 0B4B     		ldr	r3, .L128+12
 1879 0014 1C70     		strb	r4, [r3]
1528:Src/util.c    ****     HAL_Delay(100);
 1880              		.loc 1 1528 5 is_stmt 1 discriminator 3 view .LVU471
 1881 0016 6420     		movs	r0, #100
 1882 0018 FFF7FEFF 		bl	HAL_Delay
 1883              	.LVL101:
1526:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1884              		.loc 1 1526 26 discriminator 3 view .LVU472
1526:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1885              		.loc 1 1526 27 is_stmt 0 discriminator 3 view .LVU473
 1886 001c 0134     		adds	r4, r4, #1
 1887              	.LVL102:
 1888              	.L124:
1526:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1889              		.loc 1 1526 19 is_stmt 1 discriminator 1 view .LVU474
1526:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 1890              		.loc 1 1526 3 is_stmt 0 discriminator 1 view .LVU475
 1891 001e 072C     		cmp	r4, #7
 1892 0020 F7DD     		ble	.L125
 1893              	.LBE10:
1529:Src/util.c    ****   }
1530:Src/util.c    ****   saveConfig();
 1894              		.loc 1 1530 3 is_stmt 1 view .LVU476
 1895 0022 FFF7FEFF 		bl	saveConfig
 1896              	.LVL103:
1531:Src/util.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 1897              		.loc 1 1531 3 view .LVU477
 1898 0026 0022     		movs	r2, #0
 1899 0028 2021     		movs	r1, #32
 1900 002a 0648     		ldr	r0, .L128+16
ARM GAS  /tmp/ccNyZSr4.s 			page 64


 1901 002c FFF7FEFF 		bl	HAL_GPIO_WritePin
 1902              	.LVL104:
 1903              	.L126:
1532:Src/util.c    ****   while(1) {}
 1904              		.loc 1 1532 3 discriminator 1 view .LVU478
 1905              		.loc 1 1532 13 discriminator 1 view .LVU479
 1906              		.loc 1 1532 8 discriminator 1 view .LVU480
 1907 0030 FEE7     		b	.L126
 1908              	.L129:
 1909 0032 00BF     		.align	2
 1910              	.L128:
 1911 0034 00000000 		.word	enable
 1912 0038 00000000 		.word	buzzerCount
 1913 003c 00000000 		.word	buzzerPattern
 1914 0040 00000000 		.word	buzzerFreq
 1915 0044 00080140 		.word	1073809408
 1916              		.cfi_endproc
 1917              	.LFE91:
 1919              		.section	.text.filtLowPass32,"ax",%progbits
 1920              		.align	1
 1921              		.global	filtLowPass32
 1922              		.syntax unified
 1923              		.thumb
 1924              		.thumb_func
 1925              		.fpu softvfp
 1927              	filtLowPass32:
 1928              	.LVL105:
 1929              	.LFB93:
1533:Src/util.c    **** }
1534:Src/util.c    **** 
1535:Src/util.c    **** 
1536:Src/util.c    **** void poweroffPressCheck(void) {
1537:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1538:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1539:Src/util.c    ****       enable = 0;
1540:Src/util.c    ****       uint16_t cnt_press = 0;
1541:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1542:Src/util.c    ****         HAL_Delay(10);
1543:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
1544:Src/util.c    ****       }
1545:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
1546:Src/util.c    ****         HAL_Delay(1000);
1547:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
1548:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1549:Src/util.c    ****           beepLong(8);
1550:Src/util.c    ****           beepLong(8);
1551:Src/util.c    ****           beepLong(8);
1552:Src/util.c    ****           beepLong(8);
1553:Src/util.c    ****           beepLong(8);
1554:Src/util.c    ****           beepLong(8);
1555:Src/util.c    ****           beepLong(8);
1556:Src/util.c    ****           #if defined(SAFE_MODE_RPM)
1557:Src/util.c    ****           safeModeOff();
1558:Src/util.c    ****           #else
1559:Src/util.c    ****           updateCurSpdLim();
1560:Src/util.c    ****           #endif
1561:Src/util.c    ****           beepShort(5);
ARM GAS  /tmp/ccNyZSr4.s 			page 65


1562:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
1563:Src/util.c    ****           beepLong(16); 
1564:Src/util.c    ****           adcCalibLim();
1565:Src/util.c    ****           beepShort(5);
1566:Src/util.c    ****         }
1567:Src/util.c    ****       } else if (cnt_press > 8) {                         // Short press: power off (80 ms debounce
1568:Src/util.c    ****         poweroff();
1569:Src/util.c    ****       }
1570:Src/util.c    ****     }
1571:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
1572:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1573:Src/util.c    ****       enable = 0;
1574:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1575:Src/util.c    ****       beepShort(5);
1576:Src/util.c    ****       HAL_Delay(300);
1577:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1578:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1579:Src/util.c    ****         beepLong(5);
1580:Src/util.c    ****         HAL_Delay(350);
1581:Src/util.c    ****         poweroff();
1582:Src/util.c    ****       } else {
1583:Src/util.c    ****         setDistance += 0.25;
1584:Src/util.c    ****         if (setDistance > 2.6) {
1585:Src/util.c    ****           setDistance = 0.5;
1586:Src/util.c    ****         }
1587:Src/util.c    ****         beepShort(setDistance / 0.25);
1588:Src/util.c    ****         saveValue = setDistance * 1000;
1589:Src/util.c    ****         saveValue_valid = 1;
1590:Src/util.c    ****       }
1591:Src/util.c    ****     }
1592:Src/util.c    ****   #else
1593:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1594:Src/util.c    ****       enable = 0;                                             // disable motors
1595:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
1596:Src/util.c    ****       poweroff();                                             // release power-latch
1597:Src/util.c    ****     }
1598:Src/util.c    ****   #endif
1599:Src/util.c    **** }
1600:Src/util.c    **** 
1601:Src/util.c    **** 
1602:Src/util.c    **** 
1603:Src/util.c    **** /* =========================== Filtering Functions =========================== */
1604:Src/util.c    **** 
1605:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1606:Src/util.c    ****   * Max:  32767.99998474121
1607:Src/util.c    ****   * Min: -32768
1608:Src/util.c    ****   * Res:  1.52587890625e-05
1609:Src/util.c    ****   * 
1610:Src/util.c    ****   * Inputs:       u     = int16 or int32
1611:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
1612:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1613:Src/util.c    ****   * 
1614:Src/util.c    ****   * Example: 
1615:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1616:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
1617:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1618:Src/util.c    ****   */
ARM GAS  /tmp/ccNyZSr4.s 			page 66


1619:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 1930              		.loc 1 1619 58 view -0
 1931              		.cfi_startproc
 1932              		@ args = 0, pretend = 0, frame = 0
 1933              		@ frame_needed = 0, uses_anonymous_args = 0
 1934              		@ link register save eliminated.
 1935              		.loc 1 1619 58 is_stmt 0 view .LVU482
 1936 0000 2DE97003 		push	{r4, r5, r6, r8, r9}
 1937              	.LCFI19:
 1938              		.cfi_def_cfa_offset 20
 1939              		.cfi_offset 4, -20
 1940              		.cfi_offset 5, -16
 1941              		.cfi_offset 6, -12
 1942              		.cfi_offset 8, -8
 1943              		.cfi_offset 9, -4
 1944 0004 0C46     		mov	r4, r1
1620:Src/util.c    ****   int64_t tmp;  
 1945              		.loc 1 1620 3 is_stmt 1 view .LVU483
1621:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 1946              		.loc 1 1621 3 view .LVU484
 1947              		.loc 1 1621 32 is_stmt 0 view .LVU485
 1948 0006 1668     		ldr	r6, [r2]
 1949              		.loc 1 1621 35 view .LVU486
 1950 0008 3313     		asrs	r3, r6, #12
 1951              		.loc 1 1621 29 view .LVU487
 1952 000a C3EB0010 		rsb	r0, r3, r0, lsl #4
 1953              	.LVL106:
 1954              		.loc 1 1621 10 view .LVU488
 1955 000e 4FEAE079 		asr	r9, r0, #31
 1956              		.loc 1 1621 43 view .LVU489
 1957 0012 A1FB0001 		umull	r0, r1, r1, r0
 1958 0016 04FB0911 		mla	r1, r4, r9, r1
 1959              	.LVL107:
 1960              		.loc 1 1621 7 view .LVU490
 1961 001a 0409     		lsrs	r4, r0, #4
 1962 001c 44EA0174 		orr	r4, r4, r1, lsl #28
 1963 0020 0D11     		asrs	r5, r1, #4
 1964              	.LVL108:
1622:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 1965              		.loc 1 1622 3 is_stmt 1 view .LVU491
 1966              		.loc 1 1622 9 is_stmt 0 view .LVU492
 1967 0022 B4F1004F 		cmp	r4, #-2147483648
 1968 0026 75F10003 		sbcs	r3, r5, #0
 1969 002a 08DA     		bge	.L133
 1970              		.loc 1 1622 9 discriminator 1 view .LVU493
 1971 002c 2346     		mov	r3, r4
 1972 002e B4F1004F 		cmp	r4, #-2147483648
 1973 0032 75F1FF31 		sbcs	r1, r5, #-1
 1974 0036 04DA     		bge	.L131
 1975 0038 4FF00043 		mov	r3, #-2147483648
 1976 003c 01E0     		b	.L131
 1977              	.L133:
 1978              		.loc 1 1622 9 view .LVU494
 1979 003e 6FF00043 		mvn	r3, #-2147483648
 1980              	.L131:
 1981              	.LVL109:
1623:Src/util.c    ****   *y = (int32_t)tmp + (*y);
ARM GAS  /tmp/ccNyZSr4.s 			page 67


 1982              		.loc 1 1623 3 is_stmt 1 discriminator 4 view .LVU495
 1983              		.loc 1 1623 21 is_stmt 0 discriminator 4 view .LVU496
 1984 0042 1E44     		add	r6, r6, r3
 1985              		.loc 1 1623 6 discriminator 4 view .LVU497
 1986 0044 1660     		str	r6, [r2]
1624:Src/util.c    **** }
 1987              		.loc 1 1624 1 discriminator 4 view .LVU498
 1988 0046 BDE87003 		pop	{r4, r5, r6, r8, r9}
 1989              	.LCFI20:
 1990              		.cfi_restore 9
 1991              		.cfi_restore 8
 1992              		.cfi_restore 6
 1993              		.cfi_restore 5
 1994              		.cfi_restore 4
 1995              		.cfi_def_cfa_offset 0
 1996 004a 7047     		bx	lr
 1997              		.cfi_endproc
 1998              	.LFE93:
 2000              		.section	.text.adcCalibLim,"ax",%progbits
 2001              		.align	1
 2002              		.global	adcCalibLim
 2003              		.syntax unified
 2004              		.thumb
 2005              		.thumb_func
 2006              		.fpu softvfp
 2008              	adcCalibLim:
 2009              	.LFB75:
 488:Src/util.c    ****   calcAvgSpeed();
 2010              		.loc 1 488 24 is_stmt 1 view -0
 2011              		.cfi_startproc
 2012              		@ args = 0, pretend = 0, frame = 16
 2013              		@ frame_needed = 0, uses_anonymous_args = 0
 2014 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2015              	.LCFI21:
 2016              		.cfi_def_cfa_offset 36
 2017              		.cfi_offset 4, -36
 2018              		.cfi_offset 5, -32
 2019              		.cfi_offset 6, -28
 2020              		.cfi_offset 7, -24
 2021              		.cfi_offset 8, -20
 2022              		.cfi_offset 9, -16
 2023              		.cfi_offset 10, -12
 2024              		.cfi_offset 11, -8
 2025              		.cfi_offset 14, -4
 2026 0004 85B0     		sub	sp, sp, #20
 2027              	.LCFI22:
 2028              		.cfi_def_cfa_offset 56
 489:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2029              		.loc 1 489 3 view .LVU500
 2030 0006 FFF7FEFF 		bl	calcAvgSpeed
 2031              	.LVL110:
 490:Src/util.c    ****     return;
 2032              		.loc 1 490 3 view .LVU501
 490:Src/util.c    ****     return;
 2033              		.loc 1 490 19 is_stmt 0 view .LVU502
 2034 000a 5B4B     		ldr	r3, .L151
 2035 000c B3F90030 		ldrsh	r3, [r3]
ARM GAS  /tmp/ccNyZSr4.s 			page 68


 490:Src/util.c    ****     return;
 2036              		.loc 1 490 6 view .LVU503
 2037 0010 052B     		cmp	r3, #5
 2038 0012 02DD     		ble	.L150
 2039              	.L135:
 577:Src/util.c    **** /*
 2040              		.loc 1 577 1 view .LVU504
 2041 0014 05B0     		add	sp, sp, #20
 2042              	.LCFI23:
 2043              		.cfi_remember_state
 2044              		.cfi_def_cfa_offset 36
 2045              		@ sp needed
 2046 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2047              	.L150:
 2048              	.LCFI24:
 2049              		.cfi_restore_state
 500:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 2050              		.loc 1 500 3 is_stmt 1 view .LVU505
 2051 001a FFF7FEFF 		bl	readInputRaw
 2052              	.LVL111:
 502:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2053              		.loc 1 502 3 view .LVU506
 502:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2054              		.loc 1 502 40 is_stmt 0 view .LVU507
 2055 001e 574B     		ldr	r3, .L151+4
 2056 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2057 0022 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2058 0026 564A     		ldr	r2, .L151+8
 2059 0028 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 502:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2060              		.loc 1 502 45 view .LVU508
 2061 002c 1204     		lsls	r2, r2, #16
 502:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2062              		.loc 1 502 12 view .LVU509
 2063 002e 0392     		str	r2, [sp, #12]
 503:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2064              		.loc 1 503 3 is_stmt 1 view .LVU510
 503:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2065              		.loc 1 503 40 is_stmt 0 view .LVU511
 2066 0030 544A     		ldr	r2, .L151+12
 2067 0032 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 503:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2068              		.loc 1 503 45 view .LVU512
 2069 0036 1204     		lsls	r2, r2, #16
 503:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2070              		.loc 1 503 12 view .LVU513
 2071 0038 0292     		str	r2, [sp, #8]
 504:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 2072              		.loc 1 504 3 is_stmt 1 view .LVU514
 2073              	.LVL112:
 505:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 2074              		.loc 1 505 3 view .LVU515
 506:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2075              		.loc 1 506 3 view .LVU516
 507:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2076              		.loc 1 507 3 view .LVU517
 508:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
ARM GAS  /tmp/ccNyZSr4.s 			page 69


 2077              		.loc 1 508 3 view .LVU518
 509:Src/util.c    ****   int16_t  input_margin    = 0;
 2078              		.loc 1 509 3 view .LVU519
 510:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2079              		.loc 1 510 3 view .LVU520
 511:Src/util.c    ****   
 2080              		.loc 1 511 3 view .LVU521
 514:Src/util.c    ****     input_margin = ADC_MARGIN;
 2081              		.loc 1 514 3 view .LVU522
 514:Src/util.c    ****     input_margin = ADC_MARGIN;
 2082              		.loc 1 514 6 is_stmt 0 view .LVU523
 2083 003a 002B     		cmp	r3, #0
 2084 003c 42D0     		beq	.L148
 510:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2085              		.loc 1 510 12 view .LVU524
 2086 003e 0023     		movs	r3, #0
 2087 0040 0193     		str	r3, [sp, #4]
 2088              	.L138:
 2089              	.LVL113:
 510:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2090              		.loc 1 510 12 view .LVU525
 2091 0042 0025     		movs	r5, #0
 2092 0044 DFF84881 		ldr	r8, .L151+24
 2093 0048 2E46     		mov	r6, r5
 2094 004a 47F6FF79 		movw	r9, #32767
 2095 004e C246     		mov	r10, r8
 2096 0050 2F46     		mov	r7, r5
 2097 0052 CB46     		mov	fp, r9
 2098              	.LVL114:
 2099              	.L139:
 520:Src/util.c    ****     readInputRaw();
 2100              		.loc 1 520 9 is_stmt 1 view .LVU526
 520:Src/util.c    ****     readInputRaw();
 2101              		.loc 1 520 11 is_stmt 0 view .LVU527
 2102 0054 0221     		movs	r1, #2
 2103 0056 4C48     		ldr	r0, .L151+16
 2104 0058 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2105              	.LVL115:
 520:Src/util.c    ****     readInputRaw();
 2106              		.loc 1 520 9 view .LVU528
 2107 005c A8BB     		cbnz	r0, .L140
 520:Src/util.c    ****     readInputRaw();
 2108              		.loc 1 520 73 discriminator 1 view .LVU529
 2109 005e 6C1C     		adds	r4, r5, #1
 2110 0060 A4B2     		uxth	r4, r4
 2111              	.LVL116:
 520:Src/util.c    ****     readInputRaw();
 2112              		.loc 1 520 53 discriminator 1 view .LVU530
 2113 0062 B5F57A6F 		cmp	r5, #4000
 2114 0066 30D2     		bcs	.L140
 521:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2115              		.loc 1 521 5 is_stmt 1 view .LVU531
 2116 0068 FFF7FEFF 		bl	readInputRaw
 2117              	.LVL117:
 522:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2118              		.loc 1 522 5 view .LVU532
 522:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
ARM GAS  /tmp/ccNyZSr4.s 			page 70


 2119              		.loc 1 522 32 is_stmt 0 view .LVU533
 2120 006c 434D     		ldr	r5, .L151+4
 2121 006e 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2122 0070 C3EBC303 		rsb	r3, r3, r3, lsl #3
 522:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2123              		.loc 1 522 5 view .LVU534
 2124 0074 03AA     		add	r2, sp, #12
 2125 0076 41F69911 		movw	r1, #6553
 2126 007a 4148     		ldr	r0, .L151+8
 2127 007c 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2128 0080 FFF7FEFF 		bl	filtLowPass32
 2129              	.LVL118:
 523:Src/util.c    ****     
 2130              		.loc 1 523 5 is_stmt 1 view .LVU535
 523:Src/util.c    ****     
 2131              		.loc 1 523 32 is_stmt 0 view .LVU536
 2132 0084 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2133 0086 C3EBC303 		rsb	r3, r3, r3, lsl #3
 523:Src/util.c    ****     
 2134              		.loc 1 523 5 view .LVU537
 2135 008a 02AA     		add	r2, sp, #8
 2136 008c 41F69911 		movw	r1, #6553
 2137 0090 3C48     		ldr	r0, .L151+12
 2138 0092 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2139 0096 FFF7FEFF 		bl	filtLowPass32
 2140              	.LVL119:
 525:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2141              		.loc 1 525 5 is_stmt 1 view .LVU538
 525:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2142              		.loc 1 525 21 is_stmt 0 view .LVU539
 2143 009a BDF90E70 		ldrsh	r7, [sp, #14]
 2144              	.LVL120:
 526:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2145              		.loc 1 526 5 is_stmt 1 view .LVU540
 526:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2146              		.loc 1 526 21 is_stmt 0 view .LVU541
 2147 009e BDF90A60 		ldrsh	r6, [sp, #10]
 2148              	.LVL121:
 527:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2149              		.loc 1 527 5 is_stmt 1 view .LVU542
 527:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2150              		.loc 1 527 21 is_stmt 0 view .LVU543
 2151 00a2 BB45     		cmp	fp, r7
 2152 00a4 A8BF     		it	ge
 2153 00a6 BB46     		movge	fp, r7
 2154              	.LVL122:
 528:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2155              		.loc 1 528 5 is_stmt 1 view .LVU544
 528:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2156              		.loc 1 528 21 is_stmt 0 view .LVU545
 2157 00a8 BA45     		cmp	r10, r7
 2158 00aa B8BF     		it	lt
 2159 00ac BA46     		movlt	r10, r7
 2160              	.LVL123:
 529:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2161              		.loc 1 529 5 is_stmt 1 view .LVU546
 529:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
ARM GAS  /tmp/ccNyZSr4.s 			page 71


 2162              		.loc 1 529 21 is_stmt 0 view .LVU547
 2163 00ae B145     		cmp	r9, r6
 2164 00b0 A8BF     		it	ge
 2165 00b2 B146     		movge	r9, r6
 2166              	.LVL124:
 530:Src/util.c    ****     HAL_Delay(5);
 2167              		.loc 1 530 5 is_stmt 1 view .LVU548
 530:Src/util.c    ****     HAL_Delay(5);
 2168              		.loc 1 530 21 is_stmt 0 view .LVU549
 2169 00b4 B045     		cmp	r8, r6
 2170 00b6 B8BF     		it	lt
 2171 00b8 B046     		movlt	r8, r6
 2172              	.LVL125:
 531:Src/util.c    ****   }
 2173              		.loc 1 531 5 is_stmt 1 view .LVU550
 2174 00ba 0520     		movs	r0, #5
 2175 00bc FFF7FEFF 		bl	HAL_Delay
 2176              	.LVL126:
 520:Src/util.c    ****     readInputRaw();
 2177              		.loc 1 520 73 is_stmt 0 view .LVU551
 2178 00c0 2546     		mov	r5, r4
 2179 00c2 C7E7     		b	.L139
 2180              	.LVL127:
 2181              	.L148:
 515:Src/util.c    ****   }
 2182              		.loc 1 515 18 view .LVU552
 2183 00c4 6423     		movs	r3, #100
 2184 00c6 0193     		str	r3, [sp, #4]
 2185 00c8 BBE7     		b	.L138
 2186              	.LVL128:
 2187              	.L140:
 537:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2188              		.loc 1 537 3 is_stmt 1 view .LVU553
 537:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2189              		.loc 1 537 23 is_stmt 0 view .LVU554
 2190 00ca 5246     		mov	r2, r10
 2191 00cc 3946     		mov	r1, r7
 2192 00ce 5846     		mov	r0, fp
 2193 00d0 FFF7FEFF 		bl	checkInputType
 2194              	.LVL129:
 537:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2195              		.loc 1 537 16 view .LVU555
 2196 00d4 294B     		ldr	r3, .L151+4
 2197 00d6 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 537:Src/util.c    ****   if (input1[inIdx].typ == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibrat
 2198              		.loc 1 537 21 view .LVU556
 2199 00d8 C0B2     		uxtb	r0, r0
 2200 00da C3EBC301 		rsb	r1, r3, r3, lsl #3
 2201 00de 284A     		ldr	r2, .L151+8
 2202 00e0 02EB4102 		add	r2, r2, r1, lsl #1
 2203 00e4 1071     		strb	r0, [r2, #4]
 538:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2204              		.loc 1 538 3 is_stmt 1 view .LVU557
 538:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2205              		.loc 1 538 41 is_stmt 0 view .LVU558
 2206 00e6 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 538:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
ARM GAS  /tmp/ccNyZSr4.s 			page 72


 2207              		.loc 1 538 6 view .LVU559
 2208 00e8 9042     		cmp	r0, r2
 2209 00ea 09D0     		beq	.L142
 538:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2210              		.loc 1 538 49 discriminator 1 view .LVU560
 2211 00ec 032A     		cmp	r2, #3
 2212 00ee 07D0     		beq	.L142
 546:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2213              		.loc 1 546 5 is_stmt 1 view .LVU561
 546:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2214              		.loc 1 546 23 is_stmt 0 view .LVU562
 2215 00f0 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2216 00f4 224A     		ldr	r2, .L151+8
 2217 00f6 02EB4303 		add	r3, r2, r3, lsl #1
 2218 00fa 0022     		movs	r2, #0
 2219 00fc 1A71     		strb	r2, [r3, #4]
 2220 00fe 0DE0     		b	.L144
 2221              	.L142:
 539:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2222              		.loc 1 539 5 is_stmt 1 view .LVU563
 539:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2223              		.loc 1 539 41 is_stmt 0 view .LVU564
 2224 0100 0198     		ldr	r0, [sp, #4]
 2225 0102 8344     		add	fp, fp, r0
 2226              	.LVL130:
 539:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2227              		.loc 1 539 23 view .LVU565
 2228 0104 1E4A     		ldr	r2, .L151+8
 2229 0106 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2230 010a 02EB4101 		add	r1, r2, r1, lsl #1
 2231 010e A1F806B0 		strh	fp, [r1, #6]	@ movhi
 540:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2232              		.loc 1 540 5 is_stmt 1 view .LVU566
 540:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2233              		.loc 1 540 23 is_stmt 0 view .LVU567
 2234 0112 0F81     		strh	r7, [r1, #8]	@ movhi
 541:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2235              		.loc 1 541 5 is_stmt 1 view .LVU568
 541:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2236              		.loc 1 541 41 is_stmt 0 view .LVU569
 2237 0114 AAEB000A 		sub	r10, r10, r0
 2238              	.LVL131:
 541:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2239              		.loc 1 541 23 view .LVU570
 2240 0118 A1F80AA0 		strh	r10, [r1, #10]	@ movhi
 2241              	.L144:
 555:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2242              		.loc 1 555 3 is_stmt 1 view .LVU571
 555:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2243              		.loc 1 555 23 is_stmt 0 view .LVU572
 2244 011c 4246     		mov	r2, r8
 2245 011e 3146     		mov	r1, r6
 2246 0120 4846     		mov	r0, r9
 2247 0122 FFF7FEFF 		bl	checkInputType
 2248              	.LVL132:
 555:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2249              		.loc 1 555 16 view .LVU573
ARM GAS  /tmp/ccNyZSr4.s 			page 73


 2250 0126 154B     		ldr	r3, .L151+4
 2251 0128 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 555:Src/util.c    ****   if (input2[inIdx].typ == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibrat
 2252              		.loc 1 555 21 view .LVU574
 2253 012a C0B2     		uxtb	r0, r0
 2254 012c C3EBC301 		rsb	r1, r3, r3, lsl #3
 2255 0130 144A     		ldr	r2, .L151+12
 2256 0132 02EB4102 		add	r2, r2, r1, lsl #1
 2257 0136 1071     		strb	r0, [r2, #4]
 556:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2258              		.loc 1 556 3 is_stmt 1 view .LVU575
 556:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2259              		.loc 1 556 41 is_stmt 0 view .LVU576
 2260 0138 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 556:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2261              		.loc 1 556 6 view .LVU577
 2262 013a 9042     		cmp	r0, r2
 2263 013c 09D0     		beq	.L145
 556:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2264              		.loc 1 556 49 discriminator 1 view .LVU578
 2265 013e 032A     		cmp	r2, #3
 2266 0140 07D0     		beq	.L145
 564:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2267              		.loc 1 564 5 is_stmt 1 view .LVU579
 564:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2268              		.loc 1 564 23 is_stmt 0 view .LVU580
 2269 0142 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2270 0146 0F4A     		ldr	r2, .L151+12
 2271 0148 02EB4303 		add	r3, r2, r3, lsl #1
 2272 014c 0022     		movs	r2, #0
 2273 014e 1A71     		strb	r2, [r3, #4]
 2274 0150 0DE0     		b	.L147
 2275              	.L145:
 557:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2276              		.loc 1 557 5 is_stmt 1 view .LVU581
 557:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2277              		.loc 1 557 41 is_stmt 0 view .LVU582
 2278 0152 0198     		ldr	r0, [sp, #4]
 2279 0154 8144     		add	r9, r9, r0
 2280              	.LVL133:
 557:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2281              		.loc 1 557 23 view .LVU583
 2282 0156 0B4A     		ldr	r2, .L151+12
 2283 0158 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2284 015c 02EB4101 		add	r1, r2, r1, lsl #1
 2285 0160 A1F80690 		strh	r9, [r1, #6]	@ movhi
 558:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2286              		.loc 1 558 5 is_stmt 1 view .LVU584
 558:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2287              		.loc 1 558 23 is_stmt 0 view .LVU585
 2288 0164 0E81     		strh	r6, [r1, #8]	@ movhi
 559:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2289              		.loc 1 559 5 is_stmt 1 view .LVU586
 559:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2290              		.loc 1 559 41 is_stmt 0 view .LVU587
 2291 0166 A8EB0008 		sub	r8, r8, r0
 2292              	.LVL134:
ARM GAS  /tmp/ccNyZSr4.s 			page 74


 559:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2293              		.loc 1 559 23 view .LVU588
 2294 016a A1F80A80 		strh	r8, [r1, #10]	@ movhi
 2295              	.L147:
 569:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2296              		.loc 1 569 3 is_stmt 1 view .LVU589
 569:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2297              		.loc 1 569 17 is_stmt 0 view .LVU590
 2298 016e 074B     		ldr	r3, .L151+20
 2299 0170 0122     		movs	r2, #1
 2300 0172 1A70     		strb	r2, [r3]
 2301 0174 4EE7     		b	.L135
 2302              	.L152:
 2303 0176 00BF     		.align	2
 2304              	.L151:
 2305 0178 00000000 		.word	speedAvgAbs
 2306 017c 00000000 		.word	.LANCHOR5
 2307 0180 00000000 		.word	.LANCHOR3
 2308 0184 00000000 		.word	.LANCHOR4
 2309 0188 00080140 		.word	1073809408
 2310 018c 00000000 		.word	.LANCHOR11
 2311 0190 0080FFFF 		.word	-32768
 2312              		.cfi_endproc
 2313              	.LFE75:
 2315              		.section	.text.poweroffPressCheck,"ax",%progbits
 2316              		.align	1
 2317              		.global	poweroffPressCheck
 2318              		.syntax unified
 2319              		.thumb
 2320              		.thumb_func
 2321              		.fpu softvfp
 2323              	poweroffPressCheck:
 2324              	.LFB92:
1536:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2325              		.loc 1 1536 31 is_stmt 1 view -0
 2326              		.cfi_startproc
 2327              		@ args = 0, pretend = 0, frame = 0
 2328              		@ frame_needed = 0, uses_anonymous_args = 0
 2329 0000 38B5     		push	{r3, r4, r5, lr}
 2330              	.LCFI25:
 2331              		.cfi_def_cfa_offset 16
 2332              		.cfi_offset 3, -16
 2333              		.cfi_offset 4, -12
 2334              		.cfi_offset 5, -8
 2335              		.cfi_offset 14, -4
1538:Src/util.c    ****       enable = 0;
 2336              		.loc 1 1538 5 view .LVU592
1538:Src/util.c    ****       enable = 0;
 2337              		.loc 1 1538 8 is_stmt 0 view .LVU593
 2338 0002 0221     		movs	r1, #2
 2339 0004 2B48     		ldr	r0, .L168
 2340 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2341              	.LVL135:
1538:Src/util.c    ****       enable = 0;
 2342              		.loc 1 1538 7 view .LVU594
 2343 000a D0B1     		cbz	r0, .L153
 2344              	.LBB11:
ARM GAS  /tmp/ccNyZSr4.s 			page 75


1539:Src/util.c    ****       uint16_t cnt_press = 0;
 2345              		.loc 1 1539 7 is_stmt 1 view .LVU595
1539:Src/util.c    ****       uint16_t cnt_press = 0;
 2346              		.loc 1 1539 14 is_stmt 0 view .LVU596
 2347 000c 0025     		movs	r5, #0
 2348 000e 2A4B     		ldr	r3, .L168+4
 2349 0010 1D70     		strb	r5, [r3]
1540:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 2350              		.loc 1 1540 7 is_stmt 1 view .LVU597
 2351              	.LVL136:
1541:Src/util.c    ****         HAL_Delay(10);
 2352              		.loc 1 1541 7 view .LVU598
1541:Src/util.c    ****         HAL_Delay(10);
 2353              		.loc 1 1541 12 is_stmt 0 view .LVU599
 2354 0012 03E0     		b	.L155
 2355              	.LVL137:
 2356              	.L165:
1543:Src/util.c    ****       }
 2357              		.loc 1 1543 39 is_stmt 1 discriminator 1 view .LVU600
 2358 0014 0520     		movs	r0, #5
 2359 0016 FFF7FEFF 		bl	beepShort
 2360              	.LVL138:
 2361              	.L156:
 2362              	.LBE11:
1536:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2363              		.loc 1 1536 31 is_stmt 0 view .LVU601
 2364 001a 2546     		mov	r5, r4
 2365              	.LVL139:
 2366              	.L155:
 2367              	.LBB12:
1541:Src/util.c    ****         HAL_Delay(10);
 2368              		.loc 1 1541 12 is_stmt 1 view .LVU602
1541:Src/util.c    ****         HAL_Delay(10);
 2369              		.loc 1 1541 13 is_stmt 0 view .LVU603
 2370 001c 0221     		movs	r1, #2
 2371 001e 2548     		ldr	r0, .L168
 2372 0020 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2373              	.LVL140:
1541:Src/util.c    ****         HAL_Delay(10);
 2374              		.loc 1 1541 12 view .LVU604
 2375 0024 40B1     		cbz	r0, .L164
1542:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
 2376              		.loc 1 1542 9 is_stmt 1 view .LVU605
 2377 0026 0A20     		movs	r0, #10
 2378 0028 FFF7FEFF 		bl	HAL_Delay
 2379              	.LVL141:
1543:Src/util.c    ****       }
 2380              		.loc 1 1543 9 view .LVU606
1543:Src/util.c    ****       }
 2381              		.loc 1 1543 22 is_stmt 0 view .LVU607
 2382 002c 6C1C     		adds	r4, r5, #1
 2383 002e A4B2     		uxth	r4, r4
 2384              	.LVL142:
1543:Src/util.c    ****       }
 2385              		.loc 1 1543 12 view .LVU608
 2386 0030 B5F5FA7F 		cmp	r5, #500
 2387 0034 F1D1     		bne	.L156
ARM GAS  /tmp/ccNyZSr4.s 			page 76


 2388 0036 EDE7     		b	.L165
 2389              	.LVL143:
 2390              	.L164:
1545:Src/util.c    ****         HAL_Delay(1000);
 2391              		.loc 1 1545 7 is_stmt 1 view .LVU609
1545:Src/util.c    ****         HAL_Delay(1000);
 2392              		.loc 1 1545 10 is_stmt 0 view .LVU610
 2393 0038 B5F5FA7F 		cmp	r5, #500
 2394 003c 02D2     		bcs	.L166
1567:Src/util.c    ****         poweroff();
 2395              		.loc 1 1567 14 is_stmt 1 view .LVU611
1567:Src/util.c    ****         poweroff();
 2396              		.loc 1 1567 17 is_stmt 0 view .LVU612
 2397 003e 082D     		cmp	r5, #8
 2398 0040 36D8     		bhi	.L167
 2399              	.LVL144:
 2400              	.L153:
1567:Src/util.c    ****         poweroff();
 2401              		.loc 1 1567 17 view .LVU613
 2402              	.LBE12:
1599:Src/util.c    **** 
 2403              		.loc 1 1599 1 view .LVU614
 2404 0042 38BD     		pop	{r3, r4, r5, pc}
 2405              	.LVL145:
 2406              	.L166:
 2407              	.LBB13:
1546:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 2408              		.loc 1 1546 9 is_stmt 1 view .LVU615
 2409 0044 4FF47A70 		mov	r0, #1000
 2410 0048 FFF7FEFF 		bl	HAL_Delay
 2411              	.LVL146:
1547:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2412              		.loc 1 1547 9 view .LVU616
1547:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2413              		.loc 1 1547 13 is_stmt 0 view .LVU617
 2414 004c 0221     		movs	r1, #2
 2415 004e 1948     		ldr	r0, .L168
 2416 0050 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2417              	.LVL147:
1547:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2418              		.loc 1 1547 12 view .LVU618
 2419 0054 58B9     		cbnz	r0, .L159
1563:Src/util.c    ****           adcCalibLim();
 2420              		.loc 1 1563 11 is_stmt 1 view .LVU619
 2421 0056 1020     		movs	r0, #16
 2422 0058 FFF7FEFF 		bl	beepLong
 2423              	.LVL148:
1564:Src/util.c    ****           beepShort(5);
 2424              		.loc 1 1564 11 view .LVU620
 2425 005c FFF7FEFF 		bl	adcCalibLim
 2426              	.LVL149:
1565:Src/util.c    ****         }
 2427              		.loc 1 1565 11 view .LVU621
 2428 0060 0520     		movs	r0, #5
 2429 0062 FFF7FEFF 		bl	beepShort
 2430              	.LVL150:
 2431 0066 ECE7     		b	.L153
ARM GAS  /tmp/ccNyZSr4.s 			page 77


 2432              	.L161:
1548:Src/util.c    ****           beepLong(8);
 2433              		.loc 1 1548 62 discriminator 2 view .LVU622
 2434 0068 0A20     		movs	r0, #10
 2435 006a FFF7FEFF 		bl	HAL_Delay
 2436              	.LVL151:
 2437              	.L159:
1548:Src/util.c    ****           beepLong(8);
 2438              		.loc 1 1548 16 discriminator 1 view .LVU623
1548:Src/util.c    ****           beepLong(8);
 2439              		.loc 1 1548 17 is_stmt 0 discriminator 1 view .LVU624
 2440 006e 0221     		movs	r1, #2
 2441 0070 1048     		ldr	r0, .L168
 2442 0072 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2443              	.LVL152:
1548:Src/util.c    ****           beepLong(8);
 2444              		.loc 1 1548 16 discriminator 1 view .LVU625
 2445 0076 0028     		cmp	r0, #0
 2446 0078 F6D1     		bne	.L161
1549:Src/util.c    ****           beepLong(8);
 2447              		.loc 1 1549 11 is_stmt 1 view .LVU626
 2448 007a 0820     		movs	r0, #8
 2449 007c FFF7FEFF 		bl	beepLong
 2450              	.LVL153:
1550:Src/util.c    ****           beepLong(8);
 2451              		.loc 1 1550 11 view .LVU627
 2452 0080 0820     		movs	r0, #8
 2453 0082 FFF7FEFF 		bl	beepLong
 2454              	.LVL154:
1551:Src/util.c    ****           beepLong(8);
 2455              		.loc 1 1551 11 view .LVU628
 2456 0086 0820     		movs	r0, #8
 2457 0088 FFF7FEFF 		bl	beepLong
 2458              	.LVL155:
1552:Src/util.c    ****           beepLong(8);
 2459              		.loc 1 1552 11 view .LVU629
 2460 008c 0820     		movs	r0, #8
 2461 008e FFF7FEFF 		bl	beepLong
 2462              	.LVL156:
1553:Src/util.c    ****           beepLong(8);
 2463              		.loc 1 1553 11 view .LVU630
 2464 0092 0820     		movs	r0, #8
 2465 0094 FFF7FEFF 		bl	beepLong
 2466              	.LVL157:
1554:Src/util.c    ****           beepLong(8);
 2467              		.loc 1 1554 11 view .LVU631
 2468 0098 0820     		movs	r0, #8
 2469 009a FFF7FEFF 		bl	beepLong
 2470              	.LVL158:
1555:Src/util.c    ****           #if defined(SAFE_MODE_RPM)
 2471              		.loc 1 1555 11 view .LVU632
 2472 009e 0820     		movs	r0, #8
 2473 00a0 FFF7FEFF 		bl	beepLong
 2474              	.LVL159:
1557:Src/util.c    ****           #else
 2475              		.loc 1 1557 11 view .LVU633
 2476 00a4 FFF7FEFF 		bl	safeModeOff
ARM GAS  /tmp/ccNyZSr4.s 			page 78


 2477              	.LVL160:
1561:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 2478              		.loc 1 1561 11 view .LVU634
 2479 00a8 0520     		movs	r0, #5
 2480 00aa FFF7FEFF 		bl	beepShort
 2481              	.LVL161:
 2482 00ae C8E7     		b	.L153
 2483              	.L167:
1568:Src/util.c    ****       }
 2484              		.loc 1 1568 9 view .LVU635
 2485 00b0 FFF7FEFF 		bl	poweroff
 2486              	.LVL162:
 2487              	.L169:
 2488              		.align	2
 2489              	.L168:
 2490 00b4 00080140 		.word	1073809408
 2491 00b8 00000000 		.word	enable
 2492              	.LBE13:
 2493              		.cfi_endproc
 2494              	.LFE92:
 2496              		.section	.text.updateCurSpdLim,"ax",%progbits
 2497              		.align	1
 2498              		.global	updateCurSpdLim
 2499              		.syntax unified
 2500              		.thumb
 2501              		.thumb_func
 2502              		.fpu softvfp
 2504              	updateCurSpdLim:
 2505              	.LFB77:
 602:Src/util.c    ****   calcAvgSpeed();
 2506              		.loc 1 602 28 view -0
 2507              		.cfi_startproc
 2508              		@ args = 0, pretend = 0, frame = 8
 2509              		@ frame_needed = 0, uses_anonymous_args = 0
 2510 0000 30B5     		push	{r4, r5, lr}
 2511              	.LCFI26:
 2512              		.cfi_def_cfa_offset 12
 2513              		.cfi_offset 4, -12
 2514              		.cfi_offset 5, -8
 2515              		.cfi_offset 14, -4
 2516 0002 83B0     		sub	sp, sp, #12
 2517              	.LCFI27:
 2518              		.cfi_def_cfa_offset 24
 603:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2519              		.loc 1 603 3 view .LVU637
 2520 0004 FFF7FEFF 		bl	calcAvgSpeed
 2521              	.LVL163:
 604:Src/util.c    ****     return;
 2522              		.loc 1 604 3 view .LVU638
 604:Src/util.c    ****     return;
 2523              		.loc 1 604 19 is_stmt 0 view .LVU639
 2524 0008 514B     		ldr	r3, .L183
 2525 000a B3F90030 		ldrsh	r3, [r3]
 604:Src/util.c    ****     return;
 2526              		.loc 1 604 6 view .LVU640
 2527 000e 052B     		cmp	r3, #5
 2528 0010 00F39C80 		bgt	.L170
ARM GAS  /tmp/ccNyZSr4.s 			page 79


 614:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2529              		.loc 1 614 3 is_stmt 1 view .LVU641
 614:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2530              		.loc 1 614 40 is_stmt 0 view .LVU642
 2531 0014 4F4B     		ldr	r3, .L183+4
 2532 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2533 0018 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2534 001c 4E4A     		ldr	r2, .L183+8
 2535 001e 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 614:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2536              		.loc 1 614 45 view .LVU643
 2537 0022 1204     		lsls	r2, r2, #16
 614:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2538              		.loc 1 614 12 view .LVU644
 2539 0024 0192     		str	r2, [sp, #4]
 615:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2540              		.loc 1 615 3 is_stmt 1 view .LVU645
 615:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2541              		.loc 1 615 40 is_stmt 0 view .LVU646
 2542 0026 4D4A     		ldr	r2, .L183+12
 2543 0028 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 615:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2544              		.loc 1 615 45 view .LVU647
 2545 002c 1B04     		lsls	r3, r3, #16
 615:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2546              		.loc 1 615 12 view .LVU648
 2547 002e 0093     		str	r3, [sp]
 616:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 2548              		.loc 1 616 3 is_stmt 1 view .LVU649
 617:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 2549              		.loc 1 617 3 view .LVU650
 618:Src/util.c    ****   cur_spd_valid = 0;
 2550              		.loc 1 618 3 view .LVU651
 2551              	.LVL164:
 619:Src/util.c    **** 
 2552              		.loc 1 619 3 view .LVU652
 619:Src/util.c    **** 
 2553              		.loc 1 619 17 is_stmt 0 view .LVU653
 2554 0030 0024     		movs	r4, #0
 2555 0032 4B4B     		ldr	r3, .L183+16
 2556 0034 1C70     		strb	r4, [r3]
 622:Src/util.c    ****     readInputRaw();
 2557              		.loc 1 622 3 is_stmt 1 view .LVU654
 2558              	.LVL165:
 2559              	.L173:
 622:Src/util.c    ****     readInputRaw();
 2560              		.loc 1 622 9 view .LVU655
 622:Src/util.c    ****     readInputRaw();
 2561              		.loc 1 622 11 is_stmt 0 view .LVU656
 2562 0036 0221     		movs	r1, #2
 2563 0038 4A48     		ldr	r0, .L183+20
 2564 003a FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2565              	.LVL166:
 622:Src/util.c    ****     readInputRaw();
 2566              		.loc 1 622 9 view .LVU657
 2567 003e 10BB     		cbnz	r0, .L174
 622:Src/util.c    ****     readInputRaw();
ARM GAS  /tmp/ccNyZSr4.s 			page 80


 2568              		.loc 1 622 71 discriminator 1 view .LVU658
 2569 0040 631C     		adds	r3, r4, #1
 2570 0042 9DB2     		uxth	r5, r3
 2571              	.LVL167:
 622:Src/util.c    ****     readInputRaw();
 2572              		.loc 1 622 53 discriminator 1 view .LVU659
 2573 0044 B4F5FA6F 		cmp	r4, #2000
 2574 0048 1DD2     		bcs	.L174
 623:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2575              		.loc 1 623 5 is_stmt 1 view .LVU660
 2576 004a FFF7FEFF 		bl	readInputRaw
 2577              	.LVL168:
 624:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2578              		.loc 1 624 5 view .LVU661
 624:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2579              		.loc 1 624 32 is_stmt 0 view .LVU662
 2580 004e 414C     		ldr	r4, .L183+4
 2581 0050 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2582 0052 C3EBC303 		rsb	r3, r3, r3, lsl #3
 624:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2583              		.loc 1 624 5 view .LVU663
 2584 0056 01AA     		add	r2, sp, #4
 2585 0058 41F69911 		movw	r1, #6553
 2586 005c 3E48     		ldr	r0, .L183+8
 2587 005e 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2588 0062 FFF7FEFF 		bl	filtLowPass32
 2589              	.LVL169:
 625:Src/util.c    ****     HAL_Delay(5);
 2590              		.loc 1 625 5 is_stmt 1 view .LVU664
 625:Src/util.c    ****     HAL_Delay(5);
 2591              		.loc 1 625 32 is_stmt 0 view .LVU665
 2592 0066 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2593 0068 C3EBC303 		rsb	r3, r3, r3, lsl #3
 625:Src/util.c    ****     HAL_Delay(5);
 2594              		.loc 1 625 5 view .LVU666
 2595 006c 6A46     		mov	r2, sp
 2596 006e 41F69911 		movw	r1, #6553
 2597 0072 3A48     		ldr	r0, .L183+12
 2598 0074 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2599 0078 FFF7FEFF 		bl	filtLowPass32
 2600              	.LVL170:
 626:Src/util.c    ****   }
 2601              		.loc 1 626 5 is_stmt 1 view .LVU667
 2602 007c 0520     		movs	r0, #5
 2603 007e FFF7FEFF 		bl	HAL_Delay
 2604              	.LVL171:
 622:Src/util.c    ****     readInputRaw();
 2605              		.loc 1 622 71 is_stmt 0 view .LVU668
 2606 0082 2C46     		mov	r4, r5
 2607 0084 D7E7     		b	.L173
 2608              	.LVL172:
 2609              	.L174:
 629:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2610              		.loc 1 629 3 is_stmt 1 view .LVU669
 629:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2611              		.loc 1 629 16 is_stmt 0 view .LVU670
 2612 0086 334B     		ldr	r3, .L183+4
ARM GAS  /tmp/ccNyZSr4.s 			page 81


 2613 0088 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2614 008a C3EBC302 		rsb	r2, r3, r3, lsl #3
 2615 008e 3249     		ldr	r1, .L183+8
 2616 0090 01EB4201 		add	r1, r1, r2, lsl #1
 2617 0094 B1F90600 		ldrsh	r0, [r1, #6]
 2618 0098 019A     		ldr	r2, [sp, #4]
 2619 009a A2EB0042 		sub	r2, r2, r0, lsl #16
 2620 009e B1F90A10 		ldrsh	r1, [r1, #10]
 2621 00a2 091A     		subs	r1, r1, r0
 2622 00a4 92FBF1F2 		sdiv	r2, r2, r1
 629:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2623              		.loc 1 629 14 view .LVU671
 2624 00a8 B2F5803F 		cmp	r2, #65536
 2625 00ac 06DA     		bge	.L180
 629:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2626              		.loc 1 629 16 discriminator 1 view .LVU672
 2627 00ae 41F69911 		movw	r1, #6553
 2628 00b2 8A42     		cmp	r2, r1
 2629 00b4 B8BF     		it	lt
 2630 00b6 0A46     		movlt	r2, r1
 629:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2631              		.loc 1 629 14 discriminator 1 view .LVU673
 2632 00b8 91B2     		uxth	r1, r2
 2633 00ba 01E0     		b	.L176
 2634              	.L180:
 629:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2635              		.loc 1 629 14 view .LVU674
 2636 00bc 4FF6FF71 		movw	r1, #65535
 2637              	.L176:
 2638              	.LVL173:
 630:Src/util.c    ****       
 2639              		.loc 1 630 3 is_stmt 1 discriminator 4 view .LVU675
 630:Src/util.c    ****       
 2640              		.loc 1 630 16 is_stmt 0 discriminator 4 view .LVU676
 2641 00c0 C3EBC300 		rsb	r0, r3, r3, lsl #3
 2642 00c4 254A     		ldr	r2, .L183+12
 2643 00c6 02EB4000 		add	r0, r2, r0, lsl #1
 2644 00ca B0F90640 		ldrsh	r4, [r0, #6]
 2645 00ce 009A     		ldr	r2, [sp]
 2646 00d0 A2EB0442 		sub	r2, r2, r4, lsl #16
 2647 00d4 B0F90A00 		ldrsh	r0, [r0, #10]
 2648 00d8 001B     		subs	r0, r0, r4
 2649 00da 92FBF0F2 		sdiv	r2, r2, r0
 630:Src/util.c    ****       
 2650              		.loc 1 630 14 discriminator 4 view .LVU677
 2651 00de B2F5803F 		cmp	r2, #65536
 2652 00e2 06DA     		bge	.L181
 630:Src/util.c    ****       
 2653              		.loc 1 630 16 discriminator 1 view .LVU678
 2654 00e4 40F6CC40 		movw	r0, #3276
 2655 00e8 8242     		cmp	r2, r0
 2656 00ea B8BF     		it	lt
 2657 00ec 0246     		movlt	r2, r0
 630:Src/util.c    ****       
 2658              		.loc 1 630 14 discriminator 1 view .LVU679
 2659 00ee 92B2     		uxth	r2, r2
 2660 00f0 01E0     		b	.L177
ARM GAS  /tmp/ccNyZSr4.s 			page 82


 2661              	.L181:
 630:Src/util.c    ****       
 2662              		.loc 1 630 14 view .LVU680
 2663 00f2 4FF6FF72 		movw	r2, #65535
 2664              	.L177:
 2665              	.LVL174:
 632:Src/util.c    ****     // Update current limit
 2666              		.loc 1 632 3 is_stmt 1 discriminator 4 view .LVU681
 632:Src/util.c    ****     // Update current limit
 2667              		.loc 1 632 20 is_stmt 0 discriminator 4 view .LVU682
 2668 00f6 C3EBC300 		rsb	r0, r3, r3, lsl #3
 2669 00fa 174C     		ldr	r4, .L183+8
 2670 00fc 04EB4000 		add	r0, r4, r0, lsl #1
 2671 0100 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 632:Src/util.c    ****     // Update current limit
 2672              		.loc 1 632 6 discriminator 4 view .LVU683
 2673 0102 68B1     		cbz	r0, .L178
 634:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2674              		.loc 1 634 5 is_stmt 1 view .LVU684
 634:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2675              		.loc 1 634 75 is_stmt 0 view .LVU685
 2676 0104 40F2DC50 		movw	r0, #1500
 2677 0108 00FB01F1 		mul	r1, r0, r1
 2678              	.LVL175:
 634:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2679              		.loc 1 634 41 view .LVU686
 2680 010c 0913     		asrs	r1, r1, #12
 634:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2681              		.loc 1 634 39 view .LVU687
 2682 010e 1648     		ldr	r0, .L183+24
 2683 0110 A0F8CE10 		strh	r1, [r0, #206]	@ movhi
 634:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2684              		.loc 1 634 20 view .LVU688
 2685 0114 1548     		ldr	r0, .L183+28
 2686 0116 A0F8CE10 		strh	r1, [r0, #206]	@ movhi
 635:Src/util.c    ****   }
 2687              		.loc 1 635 5 is_stmt 1 view .LVU689
 635:Src/util.c    ****   }
 2688              		.loc 1 635 21 is_stmt 0 view .LVU690
 2689 011a 1149     		ldr	r1, .L183+16
 2690 011c 0120     		movs	r0, #1
 2691 011e 0870     		strb	r0, [r1]
 2692              	.L178:
 638:Src/util.c    ****     // Update speed limit
 2693              		.loc 1 638 3 is_stmt 1 view .LVU691
 638:Src/util.c    ****     // Update speed limit
 2694              		.loc 1 638 20 is_stmt 0 view .LVU692
 2695 0120 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2696 0124 0D49     		ldr	r1, .L183+12
 2697 0126 01EB4303 		add	r3, r1, r3, lsl #1
 2698 012a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 638:Src/util.c    ****     // Update speed limit
 2699              		.loc 1 638 6 view .LVU693
 2700 012c 73B1     		cbz	r3, .L170
 640:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2701              		.loc 1 640 5 is_stmt 1 view .LVU694
 640:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
ARM GAS  /tmp/ccNyZSr4.s 			page 83


 2702              		.loc 1 640 62 is_stmt 0 view .LVU695
 2703 012e 4FF47A73 		mov	r3, #1000
 2704 0132 03FB02F2 		mul	r2, r3, r2
 2705              	.LVL176:
 640:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2706              		.loc 1 640 41 view .LVU696
 2707 0136 1213     		asrs	r2, r2, #12
 640:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2708              		.loc 1 640 39 view .LVU697
 2709 0138 0B4B     		ldr	r3, .L183+24
 2710 013a A3F8DA20 		strh	r2, [r3, #218]	@ movhi
 640:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2711              		.loc 1 640 20 view .LVU698
 2712 013e 0B4B     		ldr	r3, .L183+28
 2713 0140 A3F8DA20 		strh	r2, [r3, #218]	@ movhi
 641:Src/util.c    ****   }
 2714              		.loc 1 641 5 is_stmt 1 view .LVU699
 641:Src/util.c    ****   }
 2715              		.loc 1 641 20 is_stmt 0 view .LVU700
 2716 0144 064A     		ldr	r2, .L183+16
 2717 0146 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 2718 0148 0233     		adds	r3, r3, #2
 2719 014a 1370     		strb	r3, [r2]
 2720              	.L170:
 651:Src/util.c    **** 
 2721              		.loc 1 651 1 view .LVU701
 2722 014c 03B0     		add	sp, sp, #12
 2723              	.LCFI28:
 2724              		.cfi_def_cfa_offset 12
 2725              		@ sp needed
 2726 014e 30BD     		pop	{r4, r5, pc}
 2727              	.L184:
 2728              		.align	2
 2729              	.L183:
 2730 0150 00000000 		.word	speedAvgAbs
 2731 0154 00000000 		.word	.LANCHOR5
 2732 0158 00000000 		.word	.LANCHOR3
 2733 015c 00000000 		.word	.LANCHOR4
 2734 0160 00000000 		.word	.LANCHOR12
 2735 0164 00080140 		.word	1073809408
 2736 0168 00000000 		.word	rtP_Right
 2737 016c 00000000 		.word	rtP_Left
 2738              		.cfi_endproc
 2739              	.LFE77:
 2741              		.section	.text.rateLimiter16,"ax",%progbits
 2742              		.align	1
 2743              		.global	rateLimiter16
 2744              		.syntax unified
 2745              		.thumb
 2746              		.thumb_func
 2747              		.fpu softvfp
 2749              	rateLimiter16:
 2750              	.LVL177:
 2751              	.LFB94:
1625:Src/util.c    ****   // Old filter
1626:Src/util.c    ****   // Inputs:       u     = int16
1627:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
ARM GAS  /tmp/ccNyZSr4.s 			page 84


1628:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1629:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1630:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1631:Src/util.c    ****   //   int32_t tmp;  
1632:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1633:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1634:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1635:Src/util.c    ****   // }
1636:Src/util.c    **** 
1637:Src/util.c    **** 
1638:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1639:Src/util.c    ****   * Inputs:       u     = int16
1640:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1641:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1642:Src/util.c    ****   */
1643:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 2752              		.loc 1 1643 57 is_stmt 1 view -0
 2753              		.cfi_startproc
 2754              		@ args = 0, pretend = 0, frame = 0
 2755              		@ frame_needed = 0, uses_anonymous_args = 0
 2756              		@ link register save eliminated.
1644:Src/util.c    ****   int16_t q0;
 2757              		.loc 1 1644 3 view .LVU703
1645:Src/util.c    ****   int16_t q1;
 2758              		.loc 1 1645 3 view .LVU704
1646:Src/util.c    **** 
1647:Src/util.c    ****   q0 = (u << 4)  - *y;
 2759              		.loc 1 1647 3 view .LVU705
 2760              		.loc 1 1647 11 is_stmt 0 view .LVU706
 2761 0000 0301     		lsls	r3, r0, #4
 2762 0002 9BB2     		uxth	r3, r3
 2763              		.loc 1 1647 20 view .LVU707
 2764 0004 1088     		ldrh	r0, [r2]
 2765              	.LVL178:
 2766              		.loc 1 1647 18 view .LVU708
 2767 0006 1B1A     		subs	r3, r3, r0
 2768              		.loc 1 1647 6 view .LVU709
 2769 0008 1BB2     		sxth	r3, r3
 2770              	.LVL179:
1648:Src/util.c    **** 
1649:Src/util.c    ****   if (q0 > rate) {
 2771              		.loc 1 1649 3 is_stmt 1 view .LVU710
 2772              		.loc 1 1649 6 is_stmt 0 view .LVU711
 2773 000a 8B42     		cmp	r3, r1
 2774 000c 04DC     		bgt	.L186
1650:Src/util.c    ****     q0 = rate;
1651:Src/util.c    ****   } else {
1652:Src/util.c    ****     q1 = -rate;
 2775              		.loc 1 1652 5 is_stmt 1 view .LVU712
 2776              		.loc 1 1652 8 is_stmt 0 view .LVU713
 2777 000e 4942     		rsbs	r1, r1, #0
 2778              	.LVL180:
 2779              		.loc 1 1652 8 view .LVU714
 2780 0010 09B2     		sxth	r1, r1
 2781              	.LVL181:
1653:Src/util.c    ****     if (q0 < q1) {
 2782              		.loc 1 1653 5 is_stmt 1 view .LVU715
ARM GAS  /tmp/ccNyZSr4.s 			page 85


 2783              		.loc 1 1653 8 is_stmt 0 view .LVU716
 2784 0012 8B42     		cmp	r3, r1
 2785 0014 00DB     		blt	.L186
1647:Src/util.c    **** 
 2786              		.loc 1 1647 6 view .LVU717
 2787 0016 1946     		mov	r1, r3
 2788              	.LVL182:
 2789              	.L186:
1654:Src/util.c    ****       q0 = q1;
1655:Src/util.c    ****     }
1656:Src/util.c    ****   }
1657:Src/util.c    **** 
1658:Src/util.c    ****   *y = q0 + *y;
 2790              		.loc 1 1658 3 is_stmt 1 view .LVU718
 2791              		.loc 1 1658 11 is_stmt 0 view .LVU719
 2792 0018 0144     		add	r1, r1, r0
 2793              	.LVL183:
 2794              		.loc 1 1658 6 view .LVU720
 2795 001a 1180     		strh	r1, [r2]	@ movhi
1659:Src/util.c    **** }
 2796              		.loc 1 1659 1 view .LVU721
 2797 001c 7047     		bx	lr
 2798              		.cfi_endproc
 2799              	.LFE94:
 2801              		.section	.text.mixerFcn,"ax",%progbits
 2802              		.align	1
 2803              		.global	mixerFcn
 2804              		.syntax unified
 2805              		.thumb
 2806              		.thumb_func
 2807              		.fpu softvfp
 2809              	mixerFcn:
 2810              	.LVL184:
 2811              	.LFB95:
1660:Src/util.c    **** 
1661:Src/util.c    **** 
1662:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
1663:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1664:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1665:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1666:Src/util.c    ****   */
1667:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 2812              		.loc 1 1667 95 is_stmt 1 view -0
 2813              		.cfi_startproc
 2814              		@ args = 0, pretend = 0, frame = 0
 2815              		@ frame_needed = 0, uses_anonymous_args = 0
 2816              		@ link register save eliminated.
1668:Src/util.c    ****   int16_t prodSpeed;
 2817              		.loc 1 1668 3 view .LVU723
1669:Src/util.c    ****   int16_t prodSteer;
 2818              		.loc 1 1669 3 view .LVU724
1670:Src/util.c    ****   int32_t tmp;
 2819              		.loc 1 1670 3 view .LVU725
1671:Src/util.c    **** 
1672:Src/util.c    ****   prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
 2820              		.loc 1 1672 3 view .LVU726
 2821              		.loc 1 1672 38 is_stmt 0 view .LVU727
ARM GAS  /tmp/ccNyZSr4.s 			page 86


 2822 0000 C0EB4040 		rsb	r0, r0, r0, lsl #17
 2823              	.LVL185:
 2824              		.loc 1 1672 38 view .LVU728
 2825 0004 C003     		lsls	r0, r0, #15
 2826              		.loc 1 1672 15 view .LVU729
 2827 0006 40F38F30 		sbfx	r0, r0, #14, #16
 2828              	.LVL186:
1673:Src/util.c    ****   prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 2829              		.loc 1 1673 3 is_stmt 1 view .LVU730
1674:Src/util.c    **** 
1675:Src/util.c    ****   tmp         = prodSpeed - prodSteer;  
 2830              		.loc 1 1675 3 view .LVU731
1676:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2831              		.loc 1 1676 3 view .LVU732
 2832              		.loc 1 1676 17 is_stmt 0 view .LVU733
 2833 000a 0C49     		ldr	r1, .L193
 2834              	.LVL187:
 2835              		.loc 1 1676 17 view .LVU734
 2836 000c 8842     		cmp	r0, r1
 2837 000e B8BF     		it	lt
 2838 0010 0846     		movlt	r0, r1
 2839              	.LVL188:
1677:Src/util.c    ****   *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2840              		.loc 1 1677 3 is_stmt 1 view .LVU735
1678:Src/util.c    ****   *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 2841              		.loc 1 1678 3 view .LVU736
 2842              		.loc 1 1678 17 is_stmt 0 view .LVU737
 2843 0012 0B49     		ldr	r1, .L193+4
 2844 0014 B1F90010 		ldrsh	r1, [r1]
 2845              		.loc 1 1678 15 view .LVU738
 2846 0018 B1EB201F 		cmp	r1, r0, asr #4
 2847 001c 0BDB     		blt	.L190
1667:Src/util.c    ****   int16_t prodSpeed;
 2848              		.loc 1 1667 95 discriminator 1 view .LVU739
 2849 001e 10B4     		push	{r4}
 2850              	.LCFI29:
 2851              		.cfi_def_cfa_offset 4
 2852              		.cfi_offset 4, -4
 2853 0020 0411     		asrs	r4, r0, #4
 2854              		.loc 1 1678 17 discriminator 1 view .LVU740
 2855 0022 0849     		ldr	r1, .L193+8
 2856 0024 B1F90010 		ldrsh	r1, [r1]
 2857              		.loc 1 1678 15 discriminator 1 view .LVU741
 2858 0028 A142     		cmp	r1, r4
 2859 002a B8BF     		it	lt
 2860 002c 2146     		movlt	r1, r4
 2861 002e 1180     		strh	r1, [r2]	@ movhi
1679:Src/util.c    **** 
1680:Src/util.c    ****   tmp         = prodSpeed + prodSteer;
 2862              		.loc 1 1680 3 is_stmt 1 discriminator 1 view .LVU742
1681:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2863              		.loc 1 1681 3 discriminator 1 view .LVU743
1682:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2864              		.loc 1 1682 3 discriminator 1 view .LVU744
1683:Src/util.c    ****   *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 2865              		.loc 1 1683 3 discriminator 1 view .LVU745
 2866              		.loc 1 1683 15 is_stmt 0 discriminator 1 view .LVU746
ARM GAS  /tmp/ccNyZSr4.s 			page 87


 2867 0030 1980     		strh	r1, [r3]	@ movhi
1684:Src/util.c    **** }
 2868              		.loc 1 1684 1 discriminator 1 view .LVU747
 2869 0032 10BC     		pop	{r4}
 2870              	.LCFI30:
 2871              		.cfi_restore 4
 2872              		.cfi_def_cfa_offset 0
 2873 0034 7047     		bx	lr
 2874              	.L190:
1678:Src/util.c    **** 
 2875              		.loc 1 1678 15 view .LVU748
 2876 0036 1180     		strh	r1, [r2]	@ movhi
1680:Src/util.c    ****   tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2877              		.loc 1 1680 3 is_stmt 1 view .LVU749
1681:Src/util.c    ****   *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 2878              		.loc 1 1681 3 view .LVU750
1682:Src/util.c    ****   *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 2879              		.loc 1 1682 3 view .LVU751
1683:Src/util.c    **** }
 2880              		.loc 1 1683 3 view .LVU752
1683:Src/util.c    **** }
 2881              		.loc 1 1683 15 is_stmt 0 view .LVU753
 2882 0038 1980     		strh	r1, [r3]	@ movhi
 2883 003a 7047     		bx	lr
 2884              	.L194:
 2885              		.align	2
 2886              	.L193:
 2887 003c 0080FFFF 		.word	-32768
 2888 0040 00000000 		.word	.LANCHOR0
 2889 0044 00000000 		.word	.LANCHOR1
 2890              		.cfi_endproc
 2891              	.LFE95:
 2893              		.section	.text.multipleTapDet,"ax",%progbits
 2894              		.align	1
 2895              		.global	multipleTapDet
 2896              		.syntax unified
 2897              		.thumb
 2898              		.thumb_func
 2899              		.fpu softvfp
 2901              	multipleTapDet:
 2902              	.LVL189:
 2903              	.LFB96:
1685:Src/util.c    **** 
1686:Src/util.c    **** 
1687:Src/util.c    **** 
1688:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1689:Src/util.c    **** 
1690:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1691:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1692:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1693:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1694:Src/util.c    ****   */
1695:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 2904              		.loc 1 1695 66 is_stmt 1 view -0
 2905              		.cfi_startproc
 2906              		@ args = 0, pretend = 0, frame = 0
 2907              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccNyZSr4.s 			page 88


 2908              		@ link register save eliminated.
 2909              		.loc 1 1695 66 is_stmt 0 view .LVU755
 2910 0000 30B4     		push	{r4, r5}
 2911              	.LCFI31:
 2912              		.cfi_def_cfa_offset 8
 2913              		.cfi_offset 4, -8
 2914              		.cfi_offset 5, -4
1696:Src/util.c    ****   uint8_t 	b_timeout;
 2915              		.loc 1 1696 3 is_stmt 1 view .LVU756
1697:Src/util.c    ****   uint8_t 	b_hyst;
 2916              		.loc 1 1697 3 view .LVU757
1698:Src/util.c    ****   uint8_t 	b_pulse;
 2917              		.loc 1 1698 3 view .LVU758
1699:Src/util.c    ****   uint8_t 	z_pulseCnt;
 2918              		.loc 1 1699 3 view .LVU759
1700:Src/util.c    ****   uint8_t   z_pulseCntRst;
 2919              		.loc 1 1700 3 view .LVU760
1701:Src/util.c    ****   uint32_t 	t_time; 
 2920              		.loc 1 1701 3 view .LVU761
1702:Src/util.c    **** 
1703:Src/util.c    ****   // Detect hysteresis
1704:Src/util.c    ****   if (x->b_hysteresis) {
 2921              		.loc 1 1704 3 view .LVU762
 2922              		.loc 1 1704 8 is_stmt 0 view .LVU763
 2923 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 2924              		.loc 1 1704 6 view .LVU764
 2925 0004 CCB1     		cbz	r4, .L196
1705:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 2926              		.loc 1 1705 5 is_stmt 1 view .LVU765
 2927              		.loc 1 1705 17 is_stmt 0 view .LVU766
 2928 0006 C828     		cmp	r0, #200
 2929 0008 D4BF     		ite	le
 2930 000a 0020     		movle	r0, #0
 2931              	.LVL190:
 2932              		.loc 1 1705 17 view .LVU767
 2933 000c 0120     		movgt	r0, #1
 2934              	.LVL191:
 2935              	.L197:
1706:Src/util.c    ****   } else {
1707:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
1708:Src/util.c    ****   }
1709:Src/util.c    **** 
1710:Src/util.c    ****   // Detect pulse
1711:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 2936              		.loc 1 1711 3 is_stmt 1 view .LVU768
 2937              		.loc 1 1711 21 is_stmt 0 view .LVU769
 2938 000e 231A     		subs	r3, r4, r0
 2939 0010 18BF     		it	ne
 2940 0012 0123     		movne	r3, #1
 2941              	.LVL192:
1712:Src/util.c    **** 
1713:Src/util.c    ****   // Save time when first pulse is detected
1714:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 2942              		.loc 1 1714 3 is_stmt 1 view .LVU770
 2943              		.loc 1 1714 6 is_stmt 0 view .LVU771
 2944 0014 18B1     		cbz	r0, .L198
 2945              		.loc 1 1714 14 discriminator 1 view .LVU772
ARM GAS  /tmp/ccNyZSr4.s 			page 89


 2946 0016 8442     		cmp	r4, r0
 2947 0018 01D0     		beq	.L198
 2948              		.loc 1 1714 30 discriminator 2 view .LVU773
 2949 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 2950              		.loc 1 1714 25 discriminator 2 view .LVU774
 2951 001c 9CB1     		cbz	r4, .L203
 2952              	.L198:
1715:Src/util.c    ****     t_time = timeNow;
1716:Src/util.c    ****   } else {
1717:Src/util.c    ****     t_time = x->t_timePrev;
 2953              		.loc 1 1717 5 is_stmt 1 view .LVU775
 2954              		.loc 1 1717 12 is_stmt 0 view .LVU776
 2955 001e 1568     		ldr	r5, [r2]
 2956              	.LVL193:
 2957              	.L199:
1718:Src/util.c    ****   }
1719:Src/util.c    **** 
1720:Src/util.c    ****   // Create timeout boolean
1721:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 2958              		.loc 1 1721 3 is_stmt 1 view .LVU777
 2959              		.loc 1 1721 24 is_stmt 0 view .LVU778
 2960 0020 491B     		subs	r1, r1, r5
 2961              	.LVL194:
1722:Src/util.c    **** 
1723:Src/util.c    ****   // Create pulse counter
1724:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 2962              		.loc 1 1724 3 is_stmt 1 view .LVU779
 2963              		.loc 1 1724 6 is_stmt 0 view .LVU780
 2964 0022 10B9     		cbnz	r0, .L200
 2965              		.loc 1 1724 22 discriminator 1 view .LVU781
 2966 0024 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 2967              		.loc 1 1724 17 discriminator 1 view .LVU782
 2968 0026 04B9     		cbnz	r4, .L200
1725:Src/util.c    ****     z_pulseCnt = 0U;
 2969              		.loc 1 1725 16 view .LVU783
 2970 0028 2346     		mov	r3, r4
 2971              	.LVL195:
 2972              	.L200:
1726:Src/util.c    ****   } else {
1727:Src/util.c    ****     z_pulseCnt = b_pulse;
1728:Src/util.c    ****   }
1729:Src/util.c    **** 
1730:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1731:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 2973              		.loc 1 1731 3 is_stmt 1 view .LVU784
 2974              		.loc 1 1731 9 is_stmt 0 view .LVU785
 2975 002a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 2976              		.loc 1 1731 6 view .LVU786
 2977 002c 032C     		cmp	r4, #3
 2978 002e 0CD8     		bhi	.L205
 2979              		.loc 1 1731 46 discriminator 1 view .LVU787
 2980 0030 B1F5FA6F 		cmp	r1, #2000
 2981 0034 0AD9     		bls	.L201
1732:Src/util.c    ****     z_pulseCntRst = 0U;
 2982              		.loc 1 1732 19 view .LVU788
 2983 0036 0024     		movs	r4, #0
 2984 0038 08E0     		b	.L201
ARM GAS  /tmp/ccNyZSr4.s 			page 90


 2985              	.LVL196:
 2986              	.L196:
1707:Src/util.c    ****   }
 2987              		.loc 1 1707 5 is_stmt 1 view .LVU789
1707:Src/util.c    ****   }
 2988              		.loc 1 1707 17 is_stmt 0 view .LVU790
 2989 003a B0F5167F 		cmp	r0, #600
 2990 003e D4BF     		ite	le
 2991 0040 0020     		movle	r0, #0
 2992              	.LVL197:
1707:Src/util.c    ****   }
 2993              		.loc 1 1707 17 view .LVU791
 2994 0042 0120     		movgt	r0, #1
 2995              	.LVL198:
1707:Src/util.c    ****   }
 2996              		.loc 1 1707 17 view .LVU792
 2997 0044 E3E7     		b	.L197
 2998              	.LVL199:
 2999              	.L203:
1715:Src/util.c    ****   } else {
 3000              		.loc 1 1715 12 view .LVU793
 3001 0046 0D46     		mov	r5, r1
 3002 0048 EAE7     		b	.L199
 3003              	.LVL200:
 3004              	.L205:
 3005              		.loc 1 1732 19 view .LVU794
 3006 004a 0024     		movs	r4, #0
 3007              	.L201:
 3008              	.LVL201:
1733:Src/util.c    ****   } else {
1734:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1735:Src/util.c    ****   }
1736:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 3009              		.loc 1 1736 3 is_stmt 1 view .LVU795
 3010              		.loc 1 1736 14 is_stmt 0 view .LVU796
 3011 004c 2344     		add	r3, r3, r4
 3012              	.LVL202:
 3013              		.loc 1 1736 14 view .LVU797
 3014 004e DBB2     		uxtb	r3, r3
 3015              	.LVL203:
1737:Src/util.c    **** 
1738:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1739:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 3016              		.loc 1 1739 3 is_stmt 1 view .LVU798
 3017              		.loc 1 1739 6 is_stmt 0 view .LVU799
 3018 0050 032B     		cmp	r3, #3
 3019 0052 07D9     		bls	.L202
 3020              		.loc 1 1739 39 discriminator 1 view .LVU800
 3021 0054 B1F5FA6F 		cmp	r1, #2000
 3022 0058 04D8     		bhi	.L202
1740:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 3023              		.loc 1 1740 5 is_stmt 1 view .LVU801
 3024              		.loc 1 1740 26 is_stmt 0 view .LVU802
 3025 005a 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3026              	.LVL204:
 3027              		.loc 1 1740 24 view .LVU803
 3028 005c B1FA81F1 		clz	r1, r1
ARM GAS  /tmp/ccNyZSr4.s 			page 91


 3029 0060 4909     		lsrs	r1, r1, #5
 3030              		.loc 1 1740 22 view .LVU804
 3031 0062 9171     		strb	r1, [r2, #6]
 3032              	.L202:
1741:Src/util.c    ****   }
1742:Src/util.c    **** 
1743:Src/util.c    ****   // Update states
1744:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 3033              		.loc 1 1744 3 is_stmt 1 view .LVU805
 3034              		.loc 1 1744 21 is_stmt 0 view .LVU806
 3035 0064 1371     		strb	r3, [r2, #4]
1745:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 3036              		.loc 1 1745 3 is_stmt 1 view .LVU807
 3037              		.loc 1 1745 20 is_stmt 0 view .LVU808
 3038 0066 5071     		strb	r0, [r2, #5]
 3039              	.LVL205:
1746:Src/util.c    ****   x->t_timePrev 	  = t_time;
 3040              		.loc 1 1746 3 is_stmt 1 view .LVU809
 3041              		.loc 1 1746 20 is_stmt 0 view .LVU810
 3042 0068 1560     		str	r5, [r2]
1747:Src/util.c    **** }
 3043              		.loc 1 1747 1 view .LVU811
 3044 006a 30BC     		pop	{r4, r5}
 3045              	.LCFI32:
 3046              		.cfi_restore 5
 3047              		.cfi_restore 4
 3048              		.cfi_def_cfa_offset 0
 3049              	.LVL206:
 3050              		.loc 1 1747 1 view .LVU812
 3051 006c 7047     		bx	lr
 3052              		.cfi_endproc
 3053              	.LFE96:
 3055              		.global	VirtAddVarTab
 3056              		.global	nunchuk_connected
 3057              		.global	ctrlModReq
 3058              		.global	ctrlModReqRaw
 3059              		.global	timeoutFlgSerial
 3060              		.global	timeoutFlgADC
 3061              		.comm	speedAvgAbs,2,2
 3062              		.comm	speedAvg,2,2
 3063              		.global	input2
 3064              		.global	input1
 3065              		.global	inIdx
 3066              		.comm	rtY_Right,16,4
 3067              		.comm	rtU_Right,16,4
 3068              		.comm	rtDW_Right,172,4
 3069              		.comm	rtP_Right,256,4
 3070              		.comm	rtY_Left,16,4
 3071              		.comm	rtU_Left,16,4
 3072              		.comm	rtDW_Left,172,4
 3073              		.global	rtM_Right
 3074              		.global	rtM_Left
 3075              		.comm	rtM_Right_,16,4
 3076              		.comm	rtM_Left_,16,4
 3077              		.section	.bss.INPUT_MAX,"aw",%nobits
 3078              		.align	1
 3079              		.set	.LANCHOR0,. + 0
ARM GAS  /tmp/ccNyZSr4.s 			page 92


 3082              	INPUT_MAX:
 3083 0000 0000     		.space	2
 3084              		.section	.bss.INPUT_MIN,"aw",%nobits
 3085              		.align	1
 3086              		.set	.LANCHOR1,. + 0
 3089              	INPUT_MIN:
 3090 0000 0000     		.space	2
 3091              		.section	.bss.cur_spd_valid,"aw",%nobits
 3092              		.set	.LANCHOR12,. + 0
 3095              	cur_spd_valid:
 3096 0000 00       		.space	1
 3097              		.section	.bss.inIdx,"aw",%nobits
 3098              		.set	.LANCHOR5,. + 0
 3101              	inIdx:
 3102 0000 00       		.space	1
 3103              		.section	.bss.inp_cal_valid,"aw",%nobits
 3104              		.set	.LANCHOR11,. + 0
 3107              	inp_cal_valid:
 3108 0000 00       		.space	1
 3109              		.section	.bss.nunchuk_connected,"aw",%nobits
 3112              	nunchuk_connected:
 3113 0000 00       		.space	1
 3114              		.section	.bss.timeoutFlgADC,"aw",%nobits
 3115              		.set	.LANCHOR6,. + 0
 3118              	timeoutFlgADC:
 3119 0000 00       		.space	1
 3120              		.section	.bss.timeoutFlgSerial,"aw",%nobits
 3121              		.set	.LANCHOR8,. + 0
 3124              	timeoutFlgSerial:
 3125 0000 00       		.space	1
 3126              		.section	.data.VirtAddVarTab,"aw"
 3127              		.align	2
 3128              		.set	.LANCHOR2,. + 0
 3131              	VirtAddVarTab:
 3132 0000 E803     		.short	1000
 3133 0002 E903     		.short	1001
 3134 0004 EA03     		.short	1002
 3135 0006 EB03     		.short	1003
 3136 0008 EC03     		.short	1004
 3137 000a ED03     		.short	1005
 3138 000c EE03     		.short	1006
 3139 000e EF03     		.short	1007
 3140 0010 F003     		.short	1008
 3141 0012 F103     		.short	1009
 3142 0014 F203     		.short	1010
 3143 0016 F303     		.short	1011
 3144 0018 F403     		.short	1012
 3145 001a F503     		.short	1013
 3146 001c F603     		.short	1014
 3147 001e F703     		.short	1015
 3148 0020 F803     		.short	1016
 3149 0022 F903     		.short	1017
 3150 0024 FA03     		.short	1018
 3151              		.section	.data.ctrlModReq,"aw"
 3152              		.set	.LANCHOR9,. + 0
 3155              	ctrlModReq:
 3156 0000 03       		.byte	3
ARM GAS  /tmp/ccNyZSr4.s 			page 93


 3157              		.section	.data.ctrlModReqRaw,"aw"
 3158              		.set	.LANCHOR10,. + 0
 3161              	ctrlModReqRaw:
 3162 0000 03       		.byte	3
 3163              		.section	.data.input1,"aw"
 3164              		.align	2
 3165              		.set	.LANCHOR3,. + 0
 3168              	input1:
 3169 0000 0000     		.short	0
 3170 0002 0000     		.short	0
 3171 0004 00       		.byte	0
 3172 0005 01       		.byte	1
 3173 0006 0000     		.short	0
 3174 0008 0000     		.short	0
 3175 000a C409     		.short	2500
 3176 000c 0000     		.short	0
 3177              		.section	.data.input2,"aw"
 3178              		.align	2
 3179              		.set	.LANCHOR4,. + 0
 3182              	input2:
 3183 0000 0000     		.short	0
 3184 0002 0000     		.short	0
 3185 0004 00       		.byte	0
 3186 0005 01       		.byte	1
 3187 0006 0000     		.short	0
 3188 0008 0000     		.short	0
 3189 000a 9808     		.short	2200
 3190 000c 0000     		.short	0
 3191              		.section	.data.timeoutCntADC,"aw"
 3192              		.align	1
 3193              		.set	.LANCHOR7,. + 0
 3196              	timeoutCntADC:
 3197 0000 6400     		.short	100
 3198              		.section	.rodata.rtM_Left,"a"
 3199              		.align	2
 3202              	rtM_Left:
 3203 0000 00000000 		.word	rtM_Left_
 3204              		.section	.rodata.rtM_Right,"a"
 3205              		.align	2
 3208              	rtM_Right:
 3209 0000 00000000 		.word	rtM_Right_
 3210              		.text
 3211              	.Letext0:
 3212              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 3213              		.file 3 "/usr/lib/gcc/arm-none-eabi/9.2.1/include/stddef.h"
 3214              		.file 4 "/usr/include/newlib/sys/_types.h"
 3215              		.file 5 "/usr/include/newlib/sys/reent.h"
 3216              		.file 6 "/usr/include/newlib/sys/lock.h"
 3217              		.file 7 "/usr/include/newlib/sys/_stdint.h"
 3218              		.file 8 "/usr/include/newlib/stdlib.h"
 3219              		.file 9 "Drivers/CMSIS/Include/core_cm3.h"
 3220              		.file 10 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 3221              		.file 11 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 3222              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 3223              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 3224              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 3225              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_i2c.h"
ARM GAS  /tmp/ccNyZSr4.s 			page 94


 3226              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 3227              		.file 17 "Inc/defines.h"
 3228              		.file 18 "Inc/util.h"
 3229              		.file 19 "Inc/rtwtypes.h"
 3230              		.file 20 "Inc/BLDC_controller.h"
 3231              		.file 21 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3232              		.file 22 "Inc/eeprom.h"
 3233              		.file 23 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_flash.h"
 3234              		.file 24 "<built-in>"
ARM GAS  /tmp/ccNyZSr4.s 			page 95


DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccNyZSr4.s:16     .text.BLDC_Init:0000000000000000 $t
     /tmp/ccNyZSr4.s:24     .text.BLDC_Init:0000000000000000 BLDC_Init
     /tmp/ccNyZSr4.s:136    .text.BLDC_Init:000000000000008c $d
                            *COM*:0000000000000100 rtP_Right
                            *COM*:0000000000000010 rtM_Left_
                            *COM*:00000000000000ac rtDW_Left
                            *COM*:0000000000000010 rtU_Left
                            *COM*:0000000000000010 rtY_Left
                            *COM*:0000000000000010 rtM_Right_
                            *COM*:00000000000000ac rtDW_Right
                            *COM*:0000000000000010 rtU_Right
                            *COM*:0000000000000010 rtY_Right
     /tmp/ccNyZSr4.s:150    .text.Input_Lim_Init:0000000000000000 $t
     /tmp/ccNyZSr4.s:157    .text.Input_Lim_Init:0000000000000000 Input_Lim_Init
     /tmp/ccNyZSr4.s:203    .text.Input_Lim_Init:0000000000000034 $d
     /tmp/ccNyZSr4.s:211    .text.poweronMelody:0000000000000000 $t
     /tmp/ccNyZSr4.s:218    .text.poweronMelody:0000000000000000 poweronMelody
     /tmp/ccNyZSr4.s:274    .text.poweronMelody:0000000000000024 $d
     /tmp/ccNyZSr4.s:280    .text.beepCount:0000000000000000 $t
     /tmp/ccNyZSr4.s:287    .text.beepCount:0000000000000000 beepCount
     /tmp/ccNyZSr4.s:312    .text.beepCount:0000000000000010 $d
     /tmp/ccNyZSr4.s:319    .text.beepLong:0000000000000000 $t
     /tmp/ccNyZSr4.s:326    .text.beepLong:0000000000000000 beepLong
     /tmp/ccNyZSr4.s:364    .text.beepLong:0000000000000018 $d
     /tmp/ccNyZSr4.s:370    .text.beepShort:0000000000000000 $t
     /tmp/ccNyZSr4.s:377    .text.beepShort:0000000000000000 beepShort
     /tmp/ccNyZSr4.s:415    .text.beepShort:0000000000000018 $d
     /tmp/ccNyZSr4.s:421    .text.beepShortMany:0000000000000000 $t
     /tmp/ccNyZSr4.s:428    .text.beepShortMany:0000000000000000 beepShortMany
     /tmp/ccNyZSr4.s:513    .text.calcAvgSpeed:0000000000000000 $t
     /tmp/ccNyZSr4.s:520    .text.calcAvgSpeed:0000000000000000 calcAvgSpeed
     /tmp/ccNyZSr4.s:556    .text.calcAvgSpeed:0000000000000028 $d
                            *COM*:0000000000000002 speedAvg
                            *COM*:0000000000000002 speedAvgAbs
     /tmp/ccNyZSr4.s:564    .text.safeModeOff:0000000000000000 $t
     /tmp/ccNyZSr4.s:571    .text.safeModeOff:0000000000000000 safeModeOff
     /tmp/ccNyZSr4.s:624    .text.safeModeOff:000000000000003c $d
     /tmp/ccNyZSr4.s:631    .text.standstillHold:0000000000000000 $t
     /tmp/ccNyZSr4.s:638    .text.standstillHold:0000000000000000 standstillHold
     /tmp/ccNyZSr4.s:651    .text.electricBrake:0000000000000000 $t
     /tmp/ccNyZSr4.s:658    .text.electricBrake:0000000000000000 electricBrake
     /tmp/ccNyZSr4.s:672    .text.cruiseControl:0000000000000000 $t
     /tmp/ccNyZSr4.s:679    .text.cruiseControl:0000000000000000 cruiseControl
     /tmp/ccNyZSr4.s:693    .text.checkInputType:0000000000000000 $t
     /tmp/ccNyZSr4.s:700    .text.checkInputType:0000000000000000 checkInputType
     /tmp/ccNyZSr4.s:798    .text.checkInputType:0000000000000064 $d
     /tmp/ccNyZSr4.s:803    .text.Input_Init:0000000000000000 $t
     /tmp/ccNyZSr4.s:810    .text.Input_Init:0000000000000000 Input_Init
     /tmp/ccNyZSr4.s:1114   .text.Input_Init:00000000000001a4 $d
     /tmp/ccNyZSr4.s:1124   .text.calcInputCmd:0000000000000000 $t
     /tmp/ccNyZSr4.s:1131   .text.calcInputCmd:0000000000000000 calcInputCmd
     /tmp/ccNyZSr4.s:1284   .text.readInputRaw:0000000000000000 $t
     /tmp/ccNyZSr4.s:1291   .text.readInputRaw:0000000000000000 readInputRaw
     /tmp/ccNyZSr4.s:1337   .text.readInputRaw:0000000000000028 $d
     /tmp/ccNyZSr4.s:1345   .text.handleTimeout:0000000000000000 $t
ARM GAS  /tmp/ccNyZSr4.s 			page 96


     /tmp/ccNyZSr4.s:1352   .text.handleTimeout:0000000000000000 handleTimeout
     /tmp/ccNyZSr4.s:1483   .text.handleTimeout:00000000000000b8 $d
     /tmp/ccNyZSr4.s:1496   .text.readCommand:0000000000000000 $t
     /tmp/ccNyZSr4.s:1503   .text.readCommand:0000000000000000 readCommand
     /tmp/ccNyZSr4.s:1555   .text.readCommand:0000000000000044 $d
     /tmp/ccNyZSr4.s:1564   .text.usart2_rx_check:0000000000000000 $t
     /tmp/ccNyZSr4.s:1571   .text.usart2_rx_check:0000000000000000 usart2_rx_check
     /tmp/ccNyZSr4.s:1584   .text.usart3_rx_check:0000000000000000 $t
     /tmp/ccNyZSr4.s:1591   .text.usart3_rx_check:0000000000000000 usart3_rx_check
     /tmp/ccNyZSr4.s:1604   .text.sideboardLeds:0000000000000000 $t
     /tmp/ccNyZSr4.s:1611   .text.sideboardLeds:0000000000000000 sideboardLeds
     /tmp/ccNyZSr4.s:1625   .text.sideboardSensors:0000000000000000 $t
     /tmp/ccNyZSr4.s:1632   .text.sideboardSensors:0000000000000000 sideboardSensors
     /tmp/ccNyZSr4.s:1646   .text.saveConfig:0000000000000000 $t
     /tmp/ccNyZSr4.s:1653   .text.saveConfig:0000000000000000 saveConfig
     /tmp/ccNyZSr4.s:1826   .text.saveConfig:00000000000000e4 $d
     /tmp/ccNyZSr4.s:1837   .text.poweroff:0000000000000000 $t
     /tmp/ccNyZSr4.s:1844   .text.poweroff:0000000000000000 poweroff
     /tmp/ccNyZSr4.s:1911   .text.poweroff:0000000000000034 $d
     /tmp/ccNyZSr4.s:1920   .text.filtLowPass32:0000000000000000 $t
     /tmp/ccNyZSr4.s:1927   .text.filtLowPass32:0000000000000000 filtLowPass32
     /tmp/ccNyZSr4.s:2001   .text.adcCalibLim:0000000000000000 $t
     /tmp/ccNyZSr4.s:2008   .text.adcCalibLim:0000000000000000 adcCalibLim
     /tmp/ccNyZSr4.s:2305   .text.adcCalibLim:0000000000000178 $d
     /tmp/ccNyZSr4.s:2316   .text.poweroffPressCheck:0000000000000000 $t
     /tmp/ccNyZSr4.s:2323   .text.poweroffPressCheck:0000000000000000 poweroffPressCheck
     /tmp/ccNyZSr4.s:2490   .text.poweroffPressCheck:00000000000000b4 $d
     /tmp/ccNyZSr4.s:2497   .text.updateCurSpdLim:0000000000000000 $t
     /tmp/ccNyZSr4.s:2504   .text.updateCurSpdLim:0000000000000000 updateCurSpdLim
     /tmp/ccNyZSr4.s:2730   .text.updateCurSpdLim:0000000000000150 $d
     /tmp/ccNyZSr4.s:2742   .text.rateLimiter16:0000000000000000 $t
     /tmp/ccNyZSr4.s:2749   .text.rateLimiter16:0000000000000000 rateLimiter16
     /tmp/ccNyZSr4.s:2802   .text.mixerFcn:0000000000000000 $t
     /tmp/ccNyZSr4.s:2809   .text.mixerFcn:0000000000000000 mixerFcn
     /tmp/ccNyZSr4.s:2887   .text.mixerFcn:000000000000003c $d
     /tmp/ccNyZSr4.s:2894   .text.multipleTapDet:0000000000000000 $t
     /tmp/ccNyZSr4.s:2901   .text.multipleTapDet:0000000000000000 multipleTapDet
     /tmp/ccNyZSr4.s:3131   .data.VirtAddVarTab:0000000000000000 VirtAddVarTab
     /tmp/ccNyZSr4.s:3112   .bss.nunchuk_connected:0000000000000000 nunchuk_connected
     /tmp/ccNyZSr4.s:3155   .data.ctrlModReq:0000000000000000 ctrlModReq
     /tmp/ccNyZSr4.s:3161   .data.ctrlModReqRaw:0000000000000000 ctrlModReqRaw
     /tmp/ccNyZSr4.s:3124   .bss.timeoutFlgSerial:0000000000000000 timeoutFlgSerial
     /tmp/ccNyZSr4.s:3118   .bss.timeoutFlgADC:0000000000000000 timeoutFlgADC
     /tmp/ccNyZSr4.s:3182   .data.input2:0000000000000000 input2
     /tmp/ccNyZSr4.s:3168   .data.input1:0000000000000000 input1
     /tmp/ccNyZSr4.s:3101   .bss.inIdx:0000000000000000 inIdx
     /tmp/ccNyZSr4.s:3208   .rodata.rtM_Right:0000000000000000 rtM_Right
     /tmp/ccNyZSr4.s:3202   .rodata.rtM_Left:0000000000000000 rtM_Left
     /tmp/ccNyZSr4.s:3078   .bss.INPUT_MAX:0000000000000000 $d
     /tmp/ccNyZSr4.s:3082   .bss.INPUT_MAX:0000000000000000 INPUT_MAX
     /tmp/ccNyZSr4.s:3085   .bss.INPUT_MIN:0000000000000000 $d
     /tmp/ccNyZSr4.s:3089   .bss.INPUT_MIN:0000000000000000 INPUT_MIN
     /tmp/ccNyZSr4.s:3095   .bss.cur_spd_valid:0000000000000000 cur_spd_valid
     /tmp/ccNyZSr4.s:3096   .bss.cur_spd_valid:0000000000000000 $d
     /tmp/ccNyZSr4.s:3102   .bss.inIdx:0000000000000000 $d
     /tmp/ccNyZSr4.s:3107   .bss.inp_cal_valid:0000000000000000 inp_cal_valid
     /tmp/ccNyZSr4.s:3108   .bss.inp_cal_valid:0000000000000000 $d
ARM GAS  /tmp/ccNyZSr4.s 			page 97


     /tmp/ccNyZSr4.s:3113   .bss.nunchuk_connected:0000000000000000 $d
     /tmp/ccNyZSr4.s:3119   .bss.timeoutFlgADC:0000000000000000 $d
     /tmp/ccNyZSr4.s:3125   .bss.timeoutFlgSerial:0000000000000000 $d
     /tmp/ccNyZSr4.s:3127   .data.VirtAddVarTab:0000000000000000 $d
     /tmp/ccNyZSr4.s:3164   .data.input1:0000000000000000 $d
     /tmp/ccNyZSr4.s:3178   .data.input2:0000000000000000 $d
     /tmp/ccNyZSr4.s:3192   .data.timeoutCntADC:0000000000000000 $d
     /tmp/ccNyZSr4.s:3196   .data.timeoutCntADC:0000000000000000 timeoutCntADC
     /tmp/ccNyZSr4.s:3199   .rodata.rtM_Left:0000000000000000 $d
     /tmp/ccNyZSr4.s:3205   .rodata.rtM_Right:0000000000000000 $d

UNDEFINED SYMBOLS
memcpy
BLDC_controller_initialize
rtP_Left
HAL_Delay
buzzerCount
buzzerFreq
buzzerPattern
HAL_FLASH_Unlock
EE_Init
EE_ReadVariable
HAL_FLASH_Lock
adc_buffer
timeoutFlgGen
EE_WriteVariable
HAL_GPIO_WritePin
enable
HAL_GPIO_ReadPin
